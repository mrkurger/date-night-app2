<!doctype html>
<html class="no-js" lang="">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <title>client-angular documentation</title>
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <link rel="icon" type="image/x-icon" href="../images/favicon.ico">
	   <link rel="stylesheet" href="../styles/style.css">
        <link rel="stylesheet" href="../styles/dark.css">
    </head>
    <body>
          <script>
               // Blocking script to avoid flickering dark mode
               // Dark mode toggle button
               var useDark = window.matchMedia('(prefers-color-scheme: dark)');
               var darkModeState = useDark.matches;
               var $darkModeToggleSwitchers = document.querySelectorAll('.dark-mode-switch input');
               var $darkModeToggles = document.querySelectorAll('.dark-mode-switch');
               var darkModeStateLocal = localStorage.getItem('compodoc_darkmode-state');

               function checkToggle(check) {
                    for (var i = 0; i < $darkModeToggleSwitchers.length; i++) {
                         $darkModeToggleSwitchers[i].checked = check;
                    }
               }

               function toggleDarkMode(state) {
                    if (window.localStorage) {
                         localStorage.setItem('compodoc_darkmode-state', state);
                    }

                    checkToggle(state);

                    const hasClass = document.body.classList.contains('dark');

                    if (state) {
                         for (var i = 0; i < $darkModeToggles.length; i++) {
                              $darkModeToggles[i].classList.add('dark');
                         }
                         if (!hasClass) {
                              document.body.classList.add('dark');
                         }
                    } else {
                         for (var i = 0; i < $darkModeToggles.length; i++) {
                              $darkModeToggles[i].classList.remove('dark');
                         }
                         if (hasClass) {
                              document.body.classList.remove('dark');
                         }
                    }
               }

               useDark.addEventListener('change', function (evt) {
                    toggleDarkMode(evt.matches);
               });
               if (darkModeStateLocal) {
                    darkModeState = darkModeStateLocal === 'true';
               }
               toggleDarkMode(darkModeState);
          </script>

        <div class="navbar navbar-default navbar-fixed-top d-md-none p-0">
               <div class="d-flex">
                    <a href="../" class="navbar-brand">client-angular documentation</a>
                    <button type="button" class="btn btn-default btn-menu ion-ios-menu" id="btn-menu"></button>
               </div>
        </div>

        <div class="xs-menu menu" id="mobile-menu">
                <div id="book-search-input" role="search"><input type="text" placeholder="Type to search"></div>            <compodoc-menu></compodoc-menu>
        </div>

        <div class="container-fluid main">
           <div class="row main">
               <div class="d-none d-md-block menu">
                   <compodoc-menu mode="normal"></compodoc-menu>
               </div>
               <!-- START CONTENT -->
               <div class="content interface">
                   <div class="content-data">













<ol class="breadcrumb">
  <li class="breadcrumb-item">Interfaces</li>
  <li class="breadcrumb-item"
  >
  Attachment</li>
</ol>

<ul class="nav nav-tabs" role="tablist">
        <li class="nav-item">
            <a href="#info" 
                class="nav-link"
                class="nav-link active"
                role="tab" id="info-tab" data-bs-toggle="tab" data-link="info">Info</a>
        </li>
        <li class="nav-item">
            <a href="#source" 
                class="nav-link"
                
                role="tab" id="source-tab" data-bs-toggle="tab" data-link="source">Source</a>
        </li>
</ul>

<div class="tab-content">
    <div class="tab-pane fade active in" id="info">
        <p class="comment">
            <h3>File</h3>
        </p>
        <p class="comment">
            <code>src/app/features/chat/chat.component.ts</code>
        </p>




        <section data-compodoc="block-index">
            <h3 id="index">Index</h3>
            <table class="table table-sm table-bordered index-table">
                <tbody>
                    <tr>
                        <td class="col-md-4">
                            <h6><b>Properties</b></h6>
                        </td>
                    </tr>
                    <tr>
                        <td class="col-md-4">
                            <ul class="index-list">
                                <li>
                                        <a href="#id" 
>
                                            id
                                        </a>
                                </li>
                                <li>
                                        <a href="#name" 
>
                                            name
                                        </a>
                                </li>
                                <li>
                                        <a href="#size" 
>
                                            size
                                        </a>
                                </li>
                                <li>
                                        <a href="#timestamp" 
>
                                            timestamp
                                        </a>
                                </li>
                                <li>
                                        <a href="#type" 
>
                                            type
                                        </a>
                                </li>
                                <li>
                                        <a href="#url" 
>
                                            url
                                        </a>
                                </li>
                            </ul>
                        </td>
                    </tr>
                </tbody>
            </table>
        </section>



            <section data-compodoc="block-properties">
                <h3 id="inputs">Properties</h3>
                    <table class="table table-sm table-bordered">
                        <tbody>
                                <tr>
                                    <td class="col-md-4">
                                        <a name="id"></a>
                                        <span class="name "><b>id</b>
                                            <a href="#id">
                                                <span class="icon ion-ios-link"></span>
                                            </a>
                                        </span>
                                    </td>
                                </tr>
                                <tr>
                                    <td class="col-md-4">
                                        <code>id:         <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/string" target="_blank" >string</a></code>
</code>
                                    </td>
                                </tr>


                                    <tr>
                                        <td class="col-md-4">
                                            <i>Type : </i>        <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/string" target="_blank" >string</a></code>

                                        </td>
                                    </tr>





                        </tbody>
                    </table>
                    <table class="table table-sm table-bordered">
                        <tbody>
                                <tr>
                                    <td class="col-md-4">
                                        <a name="name"></a>
                                        <span class="name "><b>name</b>
                                            <a href="#name">
                                                <span class="icon ion-ios-link"></span>
                                            </a>
                                        </span>
                                    </td>
                                </tr>
                                <tr>
                                    <td class="col-md-4">
                                        <code>name:         <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/string" target="_blank" >string</a></code>
</code>
                                    </td>
                                </tr>


                                    <tr>
                                        <td class="col-md-4">
                                            <i>Type : </i>        <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/string" target="_blank" >string</a></code>

                                        </td>
                                    </tr>





                        </tbody>
                    </table>
                    <table class="table table-sm table-bordered">
                        <tbody>
                                <tr>
                                    <td class="col-md-4">
                                        <a name="size"></a>
                                        <span class="name "><b>size</b>
                                            <a href="#size">
                                                <span class="icon ion-ios-link"></span>
                                            </a>
                                        </span>
                                    </td>
                                </tr>
                                <tr>
                                    <td class="col-md-4">
                                        <code>size:         <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/number" target="_blank" >number</a></code>
</code>
                                    </td>
                                </tr>


                                    <tr>
                                        <td class="col-md-4">
                                            <i>Type : </i>        <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/number" target="_blank" >number</a></code>

                                        </td>
                                    </tr>





                        </tbody>
                    </table>
                    <table class="table table-sm table-bordered">
                        <tbody>
                                <tr>
                                    <td class="col-md-4">
                                        <a name="timestamp"></a>
                                        <span class="name "><b>timestamp</b>
                                            <a href="#timestamp">
                                                <span class="icon ion-ios-link"></span>
                                            </a>
                                        </span>
                                    </td>
                                </tr>
                                <tr>
                                    <td class="col-md-4">
                                        <code>timestamp:         <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date" target="_blank" >Date</a></code>
</code>
                                    </td>
                                </tr>


                                    <tr>
                                        <td class="col-md-4">
                                            <i>Type : </i>        <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date" target="_blank" >Date</a></code>

                                        </td>
                                    </tr>





                        </tbody>
                    </table>
                    <table class="table table-sm table-bordered">
                        <tbody>
                                <tr>
                                    <td class="col-md-4">
                                        <a name="type"></a>
                                        <span class="name "><b>type</b>
                                            <a href="#type">
                                                <span class="icon ion-ios-link"></span>
                                            </a>
                                        </span>
                                    </td>
                                </tr>
                                <tr>
                                    <td class="col-md-4">
                                        <code>type:         <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/string" target="_blank" >string</a></code>
</code>
                                    </td>
                                </tr>


                                    <tr>
                                        <td class="col-md-4">
                                            <i>Type : </i>        <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/string" target="_blank" >string</a></code>

                                        </td>
                                    </tr>





                        </tbody>
                    </table>
                    <table class="table table-sm table-bordered">
                        <tbody>
                                <tr>
                                    <td class="col-md-4">
                                        <a name="url"></a>
                                        <span class="name "><b>url</b>
                                            <a href="#url">
                                                <span class="icon ion-ios-link"></span>
                                            </a>
                                        </span>
                                    </td>
                                </tr>
                                <tr>
                                    <td class="col-md-4">
                                        <code>url:         <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/string" target="_blank" >string</a></code>
</code>
                                    </td>
                                </tr>


                                    <tr>
                                        <td class="col-md-4">
                                            <i>Type : </i>        <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/string" target="_blank" >string</a></code>

                                        </td>
                                    </tr>





                        </tbody>
                    </table>
            </section>
    </div>


    <div class="tab-pane fade  tab-source-code" id="source">
        <pre class="line-numbers compodoc-sourcecode"><code class="language-typescript">import {
  Component,
  OnInit,
  OnDestroy,
  ViewChild,
  ElementRef,
  TemplateRef,
  AfterViewChecked,
} from &#x27;@angular/core&#x27;;
import { ChatService } from &#x27;../../core/services/chat.service&#x27;;
import { AuthService } from &#x27;../../core/services/auth.service&#x27;;
import { NotificationService } from &#x27;../../core/services/notification.service&#x27;;
import { CommonModule } from &#x27;@angular/common&#x27;;
import { FormsModule } from &#x27;@angular/forms&#x27;;
import { ActivatedRoute, Router } from &#x27;@angular/router&#x27;;
import { Subscription, BehaviorSubject, Subject } from &#x27;rxjs&#x27;;
import { debounceTime, distinctUntilChanged } from &#x27;rxjs/operators&#x27;;
import { MatDialog, MatDialogModule } from &#x27;@angular/material/dialog&#x27;;

// Material Imports
import { MatIconModule } from &#x27;@angular/material/icon&#x27;;
import { MatButtonModule } from &#x27;@angular/material/button&#x27;;
import { MatFormFieldModule } from &#x27;@angular/material/form-field&#x27;;
import { MatInputModule } from &#x27;@angular/material/input&#x27;;
import { MatMenuModule } from &#x27;@angular/material/menu&#x27;;
import { MatTooltipModule } from &#x27;@angular/material/tooltip&#x27;;
import { MatTabsModule } from &#x27;@angular/material/tabs&#x27;;

// Emerald Components
import { AvatarComponent } from &#x27;../../shared/emerald/components/avatar/avatar.component&#x27;;
import { SkeletonLoaderComponent } from &#x27;../../shared/emerald/components/skeleton-loader/skeleton-loader.component&#x27;;

// Interfaces
interface ChatMessage {
  _id: string;
  sender: {
    id: string;
    username: string;
  };
  recipient?: {
    id: string;
    username: string;
  };
  message: string;
  timestamp: Date;
  read: boolean;
  attachments?: Attachment[];
  replyTo?: string; // ID of the message being replied to
  expiresAt?: Date; // Optional expiration date for temporary messages
  ttl?: number; // Time to live in hours
  expiryWarningShown?: boolean; // Flag to track if expiry warning has been shown
}

interface Contact {
  id: string;
  name: string;
  imageUrl?: string;
  lastMessage: string;
  lastMessageTime: Date;
  lastSeen?: Date;
  unreadCount: number;
  online: boolean;
  typing?: boolean;
  pinned?: boolean;
  archived?: boolean;
}

interface MessageGroup {
  date: Date;
  messages: ChatMessage[];
}

interface Attachment {
  id: string;
  name: string;
  type: string;
  size: number;
  url: string;
  timestamp: Date;
}

interface EmojiCategory {
  name: string;
  icon: string;
  emojis: string[];
}

// Constants
const MAX_ATTACHMENT_SIZE &#x3D; 10 * 1024 * 1024; // 10MB
const TYPING_INDICATOR_DELAY &#x3D; 500; // ms

@Component({
  selector: &#x27;app-chat&#x27;,
  standalone: true,
  imports: [
    CommonModule,
    FormsModule,
    MatIconModule,
    MatButtonModule,
    MatFormFieldModule,
    MatInputModule,
    MatMenuModule,
    MatTooltipModule,
    MatTabsModule,
    MatDialogModule,
    AvatarComponent,
    SkeletonLoaderComponent,
  ],
  templateUrl: &#x27;./chat.component.html&#x27;,
  styleUrls: [&#x27;./chat.component.scss&#x27;],
})
export class ChatComponent implements OnInit, OnDestroy, AfterViewChecked {
  // ViewChild references
  @ViewChild(&#x27;messageList&#x27;) messageList!: ElementRef;
  @ViewChild(&#x27;messageInput&#x27;) messageInput!: ElementRef;
  @ViewChild(&#x27;newMessageDialog&#x27;) newMessageDialog!: TemplateRef&lt;any&gt;;
  @ViewChild(&#x27;imagePreviewDialog&#x27;) imagePreviewDialog!: TemplateRef&lt;any&gt;;
  @ViewChild(&#x27;searchInChatDialog&#x27;) searchInChatDialog!: TemplateRef&lt;any&gt;;
  @ViewChild(&#x27;mediaGalleryDialog&#x27;) mediaGalleryDialog!: TemplateRef&lt;any&gt;;

  // Chat data
  messages: ChatMessage[] &#x3D; [];
  messageGroups: MessageGroup[] &#x3D; [];
  contacts: Contact[] &#x3D; [];
  filteredContacts: Contact[] &#x3D; [];
  newMessage &#x3D; &#x27;&#x27;;
  currentUserId &#x3D; &#x27;&#x27;;
  selectedContactId: string | null &#x3D; null;
  searchTerm &#x3D; &#x27;&#x27;;

  // UI state
  loadingContacts &#x3D; true;
  isContactTyping &#x3D; false;
  showEmojiPicker &#x3D; false;
  notificationsEnabled &#x3D; true;
  currentFilter: &#x27;all&#x27; | &#x27;unread&#x27; | &#x27;archived&#x27; &#x3D; &#x27;all&#x27;;

  // Reply functionality
  replyingTo: ChatMessage | null &#x3D; null;

  // Temporary message functionality
  temporaryMessageMode &#x3D; false;
  temporaryMessageTTL &#x3D; 24; // Default: 24 hours
  expiryCheckInterval: any; // For the timer that checks expired messages

  // Message auto-deletion settings
  messageAutoDeletionEnabled &#x3D; true;
  messageExpiryTime &#x3D; 7 * 24 * 60 * 60 * 1000; // 7 days in milliseconds
  temporaryMessageMode &#x3D; false; // When true, next message will be temporary
  temporaryMessageTTL &#x3D; 24 * 60 * 60 * 1000; // 24 hours in milliseconds

  // New message dialog
  newMessageSearch &#x3D; &#x27;&#x27;;
  filteredNewMessageContacts: Contact[] &#x3D; [];

  // Image preview
  previewImage: Attachment | null &#x3D; null;

  // Search in chat
  chatSearchQuery &#x3D; &#x27;&#x27;;
  chatSearchResults: ChatMessage[] &#x3D; [];

  // Media gallery
  galleryTab: &#x27;images&#x27; | &#x27;files&#x27; | &#x27;links&#x27; &#x3D; &#x27;images&#x27;;
  galleryImages: Attachment[] &#x3D; [];
  galleryFiles: Attachment[] &#x3D; [];
  galleryLinks: { url: string; title?: string; timestamp: Date }[] &#x3D; [];

  // Emoji picker
  emojiCategories: EmojiCategory[] &#x3D; [
    {
      name: &#x27;Smileys &amp; Emotion&#x27;,
      icon: &#x27;sentiment_satisfied_alt&#x27;,
      emojis: [
        &#x27;😀&#x27;,
        &#x27;😃&#x27;,
        &#x27;😄&#x27;,
        &#x27;😁&#x27;,
        &#x27;😆&#x27;,
        &#x27;😅&#x27;,
        &#x27;😂&#x27;,
        &#x27;🤣&#x27;,
        &#x27;😊&#x27;,
        &#x27;😇&#x27;,
        &#x27;🙂&#x27;,
        &#x27;🙃&#x27;,
        &#x27;😉&#x27;,
        &#x27;😌&#x27;,
        &#x27;😍&#x27;,
        &#x27;🥰&#x27;,
        &#x27;😘&#x27;,
      ],
    },
    {
      name: &#x27;People &amp; Body&#x27;,
      icon: &#x27;person&#x27;,
      emojis: [
        &#x27;👍&#x27;,
        &#x27;👎&#x27;,
        &#x27;👌&#x27;,
        &#x27;✌️&#x27;,
        &#x27;🤞&#x27;,
        &#x27;🤟&#x27;,
        &#x27;🤘&#x27;,
        &#x27;🤙&#x27;,
        &#x27;👈&#x27;,
        &#x27;👉&#x27;,
        &#x27;👆&#x27;,
        &#x27;👇&#x27;,
        &#x27;👋&#x27;,
        &#x27;🤚&#x27;,
        &#x27;🖐️&#x27;,
        &#x27;✋&#x27;,
        &#x27;🖖&#x27;,
      ],
    },
    {
      name: &#x27;Objects&#x27;,
      icon: &#x27;emoji_objects&#x27;,
      emojis: [
        &#x27;❤️&#x27;,
        &#x27;🧡&#x27;,
        &#x27;💛&#x27;,
        &#x27;💚&#x27;,
        &#x27;💙&#x27;,
        &#x27;💜&#x27;,
        &#x27;🖤&#x27;,
        &#x27;💔&#x27;,
        &#x27;❣️&#x27;,
        &#x27;💕&#x27;,
        &#x27;💞&#x27;,
        &#x27;💓&#x27;,
        &#x27;💗&#x27;,
        &#x27;💖&#x27;,
        &#x27;💘&#x27;,
        &#x27;💝&#x27;,
        &#x27;💟&#x27;,
      ],
    },
  ];
  currentCategoryEmojis: string[] &#x3D; this.emojiCategories[0].emojis;

  // Subscriptions
  private subscriptions: Subscription[] &#x3D; [];
  private typingSubject &#x3D; new Subject&lt;string&gt;();
  private shouldScrollToBottom &#x3D; true;

  constructor(
    private chatService: ChatService,
    private authService: AuthService,
    private notificationService: NotificationService,
    private route: ActivatedRoute,
    private router: Router,
    private dialog: MatDialog
  ) {
    const currentUser &#x3D; this.authService.getCurrentUser();
    this.currentUserId &#x3D; currentUser ? currentUser._id : &#x27;&#x27;;

    // Set up typing indicator with debounce
    const typingSub &#x3D; this.typingSubject
      .pipe(debounceTime(TYPING_INDICATOR_DELAY), distinctUntilChanged())
      .subscribe(message &#x3D;&gt; {
        if (this.selectedContactId) {
          this.chatService.sendTypingIndicator(this.selectedContactId);
        }
      });

    this.subscriptions.push(typingSub);
  }

  ngOnInit(): void {
    // Load contacts first
    this.loadContacts();

    // Check if we have a recipient ID in the route
    const routeSub &#x3D; this.route.params.subscribe(params &#x3D;&gt; {
      if (params[&#x27;userId&#x27;]) {
        this.selectedContactId &#x3D; params[&#x27;userId&#x27;];
        this.loadMessages();
        this.loadMessageAutoDeletionSettings();
      }
    });

    this.subscriptions.push(routeSub);
    this.setupSocketListeners();

    // Set up a timer to check for expired messages every minute
    this.expiryCheckInterval &#x3D; setInterval(() &#x3D;&gt; {
      this.checkExpiredMessages();
    }, 60000); // 60000 ms &#x3D; 1 minute
  }

  /**
   * Load message auto-deletion settings for the current chat room
   */
  loadMessageAutoDeletionSettings(): void {
    if (!this.selectedContactId) return;

    const settings &#x3D; this.chatService.getMessageAutoDeletionSettings(this.selectedContactId);
    this.messageAutoDeletionEnabled &#x3D; settings.enabled;
    this.messageExpiryTime &#x3D; settings.ttl;

    console.log(
      &#x60;Loaded message auto-deletion settings for room ${this.selectedContactId}: enabled&#x3D;${settings.enabled}, ttl&#x3D;${this.formatTTL(settings.ttl)}&#x60;
    );
  }

  ngAfterViewChecked(): void {
    // Scroll to bottom if needed
    if (this.shouldScrollToBottom &amp;&amp; this.messageList) {
      this.scrollToBottom();
      this.shouldScrollToBottom &#x3D; false;
    }
  }

  ngOnDestroy(): void {
    // Clean up subscriptions
    this.subscriptions.forEach(sub &#x3D;&gt; sub.unsubscribe());

    // Clear the expiry check interval
    if (this.expiryCheckInterval) {
      clearInterval(this.expiryCheckInterval);
    }
  }

  /**
   * Load contacts from the server
   */
  loadContacts(): void {
    this.loadingContacts &#x3D; true;

    // In a real app, you would load contacts from the service
    this.chatService.getContacts().subscribe({
      next: contacts &#x3D;&gt; {
        this.contacts &#x3D; this.enhanceContacts(contacts);
        this.filterContacts();

        // If we have contacts but no selected contact, select the first one
        if (this.contacts.length &gt; 0 &amp;&amp; !this.selectedContactId) {
          this.selectContact(this.contacts[0].id);
        }

        this.loadingContacts &#x3D; false;
      },
      error: err &#x3D;&gt; {
        console.error(&#x27;Error loading contacts:&#x27;, err);
        // Use mock data if API call fails
        this.contacts &#x3D; this.enhanceContacts(this.chatService.getMockContacts());
        this.filterContacts();

        if (this.contacts.length &gt; 0 &amp;&amp; !this.selectedContactId) {
          this.selectContact(this.contacts[0].id);
        }

        this.loadingContacts &#x3D; false;
      },
    });
  }

  /**
   * Enhance contacts with additional properties for UI
   */
  enhanceContacts(contacts: any[]): Contact[] {
    return contacts.map(contact &#x3D;&gt; ({
      ...contact,
      imageUrl: contact.imageUrl || this.getRandomProfileImage(),
      lastSeen: contact.lastSeen || new Date(Date.now() - Math.random() * 1000 * 60 * 60 * 24),
      pinned: contact.pinned || false,
      archived: contact.archived || false,
      typing: false,
    }));
  }

  /**
   * Load messages for the selected contact
   */
  loadMessages(): void {
    if (this.selectedContactId) {
      this.chatService.getMessages(this.selectedContactId).subscribe({
        next: messages &#x3D;&gt; {
          // Transform the messages from the service format to the component format
          this.messages &#x3D; this.transformMessages(messages);

          // Group messages by date
          this.groupMessagesByDate();

          // Mark messages as read
          this.markContactMessagesAsRead();

          // Scroll to bottom of message list
          this.shouldScrollToBottom &#x3D; true;

          // Extract media for gallery
          this.extractMediaFromMessages();
        },
        error: err &#x3D;&gt; {
          console.error(&#x27;Error loading messages:&#x27;, err);

          // If no messages, create dummy messages for demo
          if (this.selectedContactId &amp;&amp; this.messages.length &#x3D;&#x3D;&#x3D; 0) {
            const contact &#x3D; this.getSelectedContact();
            if (contact) {
              this.createDummyMessages(contact);
              this.groupMessagesByDate();
              this.extractMediaFromMessages();
            }
          }
        },
      });
    }
  }

  /**
   * Transform messages from API format to component format
   */
  transformMessages(messages: any[]): ChatMessage[] {
    return messages.map(msg &#x3D;&gt; {
      // Create a properly typed sender object
      let senderObj: { id: string; username: string };
      if (typeof msg.sender &#x3D;&#x3D;&#x3D; &#x27;string&#x27;) {
        senderObj &#x3D; {
          id: msg.sender,
          username: this.getContactById(msg.sender)?.name || &#x27;User&#x27;,
        };
      } else {
        // Handle the case where sender is an object
        const senderAsObj &#x3D; msg.sender;
        senderObj &#x3D; {
          id: senderAsObj.id || &#x27;unknown&#x27;,
          username:
            senderAsObj.username || this.getContactById(senderAsObj.id)?.name || &#x27;Unknown User&#x27;,
        };
      }

      // Create a properly typed recipient object if it exists
      let recipientObj: { id: string; username: string } | undefined;
      if (msg.recipient) {
        if (typeof msg.recipient &#x3D;&#x3D;&#x3D; &#x27;string&#x27;) {
          recipientObj &#x3D; {
            id: msg.recipient,
            username: this.getContactById(msg.recipient)?.name || &#x27;Recipient&#x27;,
          };
        } else {
          // Handle the case where recipient is an object
          const recipientAsObj &#x3D; msg.recipient;
          recipientObj &#x3D; {
            id: recipientAsObj.id || &#x27;unknown&#x27;,
            username:
              recipientAsObj.username ||
              this.getContactById(recipientAsObj.id)?.name ||
              &#x27;Unknown Recipient&#x27;,
          };
        }
      }

      // Create attachments if they exist
      const attachments &#x3D; msg.attachments ? this.transformAttachments(msg.attachments) : undefined;

      return {
        _id: msg._id,
        sender: senderObj,
        recipient: recipientObj,
        message: msg.message || msg.content,
        timestamp: new Date(msg.timestamp),
        read: msg.read,
        attachments,
        replyTo: msg.replyTo,
      };
    });
  }

  /**
   * Transform attachments from API format to component format
   */
  transformAttachments(attachments: any[]): Attachment[] {
    return attachments.map(att &#x3D;&gt; ({
      id: att.id || att._id || Date.now().toString(),
      name: att.name || att.filename || &#x27;Attachment&#x27;,
      type: att.type || att.mimeType || &#x27;application/octet-stream&#x27;,
      size: att.size || 0,
      url: att.url || att.path || &#x27;&#x27;,
      timestamp: new Date(att.timestamp || att.createdAt || Date.now()),
    }));
  }

  /**
   * Group messages by date for display
   */
  groupMessagesByDate(): void {
    const groups: { [key: string]: MessageGroup } &#x3D; {};

    this.messages.forEach(message &#x3D;&gt; {
      const date &#x3D; new Date(message.timestamp);
      const dateKey &#x3D; date.toDateString();

      if (!groups[dateKey]) {
        groups[dateKey] &#x3D; {
          date: date,
          messages: [],
        };
      }

      groups[dateKey].messages.push(message);
    });

    this.messageGroups &#x3D; Object.values(groups).sort((a, b) &#x3D;&gt; a.date.getTime() - b.date.getTime());
  }

  /**
   * Extract media from messages for gallery view
   */
  extractMediaFromMessages(): void {
    this.galleryImages &#x3D; [];
    this.galleryFiles &#x3D; [];
    this.galleryLinks &#x3D; [];

    this.messages.forEach(message &#x3D;&gt; {
      // Extract attachments
      if (message.attachments &amp;&amp; message.attachments.length &gt; 0) {
        message.attachments.forEach(attachment &#x3D;&gt; {
          if (this.isImageAttachment(attachment)) {
            this.galleryImages.push(attachment);
          } else {
            this.galleryFiles.push(attachment);
          }
        });
      }

      // Extract links from message text
      const urlRegex &#x3D; /(https?:\/\/[^\s]+)/g;
      const matches &#x3D; message.message.match(urlRegex);

      if (matches) {
        matches.forEach(url &#x3D;&gt; {
          this.galleryLinks.push({
            url,
            timestamp: message.timestamp,
          });
        });
      }
    });
  }

  /**
   * Send a message to the selected contact
   */
  sendMessage(): void {
    if (this.canSendMessage()) {
      const replyToId &#x3D; this.replyingTo?._id;

      // Determine if this should be a temporary message with custom TTL
      let ttl: number | undefined;
      if (this.temporaryMessageMode) {
        // Convert hours to milliseconds
        ttl &#x3D; this.chatService.convertHoursToMilliseconds(this.temporaryMessageTTL);
        // Reset temporary message mode after sending
        this.temporaryMessageMode &#x3D; false;
      } else if (this.messageAutoDeletionEnabled) {
        ttl &#x3D; this.messageExpiryTime;
      }

      this.chatService
        .sendMessage(this.selectedContactId, this.newMessage, replyToId, ttl)
        .subscribe({
          next: response &#x3D;&gt; {
            // Add the message to our list immediately for better UX
            const newMessage: ChatMessage &#x3D; {
              _id: response._id || Date.now().toString(),
              sender: {
                id: this.currentUserId,
                username: &#x27;You&#x27;,
              },
              message: this.newMessage,
              timestamp: new Date(),
              read: false,
              replyTo: replyToId,
              expiresAt: response.expiresAt || (ttl ? Date.now() + ttl : undefined),
            };

            this.messages &#x3D; [...this.messages, newMessage];
            this.groupMessagesByDate();
            this.newMessage &#x3D; &#x27;&#x27;;
            this.replyingTo &#x3D; null;

            // Update the last message in contacts
            this.updateContactLastMessage(this.selectedContactId, newMessage.message);

            // Scroll to bottom
            this.shouldScrollToBottom &#x3D; true;
          },
          error: err &#x3D;&gt; {
            console.error(&#x27;Error sending message:&#x27;, err);
            this.notificationService.error(&#x27;Failed to send message. Please try again.&#x27;);
          },
        });
    }
  }

  /**
   * Toggle temporary message mode
   * When enabled, the next message sent will auto-delete after the specified TTL
   */
  toggleTemporaryMessageMode(): void {
    this.temporaryMessageMode &#x3D; !this.temporaryMessageMode;

    if (this.temporaryMessageMode) {
      this.notificationService.info(
        &#x60;Temporary message mode enabled. Next message will auto-delete after ${this.formatTTL(this.temporaryMessageTTL)}.&#x60;
      );
    } else {
      this.notificationService.info(&#x27;Temporary message mode disabled.&#x27;);
    }
  }

  /**
   * Set the TTL for temporary messages
   * @param hours Number of hours before the message auto-deletes
   */
  setTemporaryMessageTTL(hours: number): void {
    this.temporaryMessageTTL &#x3D; hours * 60 * 60 * 1000;

    if (this.temporaryMessageMode) {
      this.notificationService.info(
        &#x60;Temporary messages will auto-delete after ${this.formatTTL(this.temporaryMessageTTL)}.&#x60;
      );
    }
  }

  /**
   * Format a TTL value in milliseconds to a human-readable string
   */
  private formatTTL(ttl: number): string {
    const hours &#x3D; ttl / (60 * 60 * 1000);

    if (hours &lt; 1) {
      return &#x60;${Math.round(hours * 60)} minutes&#x60;;
    } else if (hours &#x3D;&#x3D;&#x3D; 1) {
      return &#x27;1 hour&#x27;;
    } else if (hours &lt; 24) {
      return &#x60;${hours} hours&#x60;;
    } else {
      const days &#x3D; hours / 24;
      if (days &#x3D;&#x3D;&#x3D; 1) {
        return &#x27;1 day&#x27;;
      } else {
        return &#x60;${days} days&#x60;;
      }
    }
  }

  /**
   * Configure message auto-deletion settings for the current chat room
   */
  configureMessageAutoDeletion(enabled: boolean, days: number): void {
    if (!this.selectedContactId) return;

    const ttl &#x3D; days * 24 * 60 * 60 * 1000;
    this.messageAutoDeletionEnabled &#x3D; enabled;
    this.messageExpiryTime &#x3D; ttl;

    this.chatService.configureMessageAutoDeletion(this.selectedContactId, enabled, ttl).subscribe({
      next: success &#x3D;&gt; {
        if (success) {
          this.notificationService.success(
            enabled
              ? &#x60;Messages will auto-delete after ${days} days.&#x60;
              : &#x27;Message auto-deletion disabled.&#x27;
          );
        } else {
          this.notificationService.error(&#x27;Failed to update message auto-deletion settings.&#x27;);
        }
      },
      error: err &#x3D;&gt; {
        console.error(&#x27;Error configuring message auto-deletion:&#x27;, err);
        this.notificationService.error(&#x27;Failed to update message auto-deletion settings.&#x27;);
      },
    });
  }

  /**
   * Check if a message can be sent
   */
  canSendMessage(): boolean {
    return !!this.newMessage.trim() &amp;&amp; !!this.selectedContactId;
  }

  /**
   * Toggle temporary message mode
   */
  toggleTemporaryMessageMode(): void {
    this.temporaryMessageMode &#x3D; !this.temporaryMessageMode;

    // Focus on the message input after toggling
    setTimeout(() &#x3D;&gt; {
      if (this.messageInput) {
        this.messageInput.nativeElement.focus();
      }
    }, 0);
  }

  /**
   * Set the TTL (time to live) for temporary messages
   * @param hours Number of hours before the message expires
   */
  setTemporaryMessageTTL(hours: number): void {
    this.temporaryMessageTTL &#x3D; hours;
  }

  /**
   * Format the TTL for display
   * @param hours Number of hours
   * @returns Formatted string (e.g., &quot;1 hour&quot;, &quot;24 hours&quot;)
   */
  formatTTL(hours: number): string {
    return hours &#x3D;&#x3D;&#x3D; 1 ? &#x27;1 hour&#x27; : &#x60;${hours} hours&#x60;;
  }

  /**
   * Check for expired messages and remove them from the UI
   * This should be called periodically to clean up expired messages
   */
  checkExpiredMessages(): void {
    const now &#x3D; new Date().getTime();
    const expiredMessageIds: string[] &#x3D; [];
    const aboutToExpireIds: string[] &#x3D; [];
    const warningThreshold &#x3D; 5 * 60 * 1000; // 5 minutes

    // Find expired and about-to-expire messages
    this.messages.forEach(message &#x3D;&gt; {
      if (message.expiresAt) {
        const expiryTime &#x3D; new Date(message.expiresAt).getTime();

        if (expiryTime &lt;&#x3D; now) {
          // Message has expired
          expiredMessageIds.push(message._id);
        } else if (expiryTime - now &lt;&#x3D; warningThreshold &amp;&amp; !message.expiryWarningShown) {
          // Message will expire soon and warning hasn&#x27;t been shown yet
          aboutToExpireIds.push(message._id);
          message.expiryWarningShown &#x3D; true; // Mark that we&#x27;ve shown the warning
        }
      }
    });

    // Show warnings for messages about to expire
    if (aboutToExpireIds.length &gt; 0) {
      if (aboutToExpireIds.length &#x3D;&#x3D;&#x3D; 1) {
        this.notificationService.info(&#x27;A message will expire soon&#x27;);
      } else {
        this.notificationService.info(&#x60;${aboutToExpireIds.length} messages will expire soon&#x60;);
      }
    }

    // Remove expired messages
    if (expiredMessageIds.length &gt; 0) {
      this.messages &#x3D; this.messages.filter(message &#x3D;&gt; !expiredMessageIds.includes(message._id));
      this.groupMessagesByDate();

      // Notify the user that messages have expired
      if (expiredMessageIds.length &#x3D;&#x3D;&#x3D; 1) {
        this.notificationService.info(&#x27;A temporary message has expired and been removed&#x27;);
      } else {
        this.notificationService.info(
          &#x60;${expiredMessageIds.length} temporary messages have expired and been removed&#x60;
        );
      }
    }
  }

  /**
   * Calculate the remaining time for a temporary message
   * @param expiresAt The expiration timestamp
   * @returns Formatted string showing remaining time
   */
  getRemainingTime(expiresAt: Date): string {
    if (!expiresAt) {
      return &#x27;&#x27;;
    }

    const now &#x3D; new Date().getTime();
    const expiry &#x3D; new Date(expiresAt).getTime();
    const diff &#x3D; expiry - now;

    if (diff &lt;&#x3D; 0) {
      return &#x27;Expired&#x27;;
    }

    // Convert to appropriate units
    const seconds &#x3D; Math.floor(diff / 1000);
    const minutes &#x3D; Math.floor(seconds / 60);
    const hours &#x3D; Math.floor(minutes / 60);
    const days &#x3D; Math.floor(hours / 24);

    if (days &gt; 0) {
      return &#x60;${days}d remaining&#x60;;
    } else if (hours &gt; 0) {
      return &#x60;${hours}h remaining&#x60;;
    } else if (minutes &gt; 0) {
      return &#x60;${minutes}m remaining&#x60;;
    } else {
      return &#x60;${seconds}s remaining&#x60;;
    }
  }

  /**
   * Check if a message is about to expire (within 5 minutes)
   * @param expiresAt The expiration timestamp
   * @returns True if the message will expire within 5 minutes
   */
  isAboutToExpire(expiresAt: Date): boolean {
    if (!expiresAt) {
      return false;
    }

    const now &#x3D; new Date().getTime();
    const expiry &#x3D; new Date(expiresAt).getTime();
    const diff &#x3D; expiry - now;
    const warningThreshold &#x3D; 5 * 60 * 1000; // 5 minutes

    return diff &gt; 0 &amp;&amp; diff &lt;&#x3D; warningThreshold;
  }

  /**
   * Handle Enter key in message input
   */
  handleEnterKey(event: Event): void {
    const keyboardEvent &#x3D; event as KeyboardEvent;
    if (!keyboardEvent.shiftKey) {
      event.preventDefault();
      this.sendMessage();
    }
  }

  /**
   * Notify that user is typing
   */
  onTyping(): void {
    this.typingSubject.next(this.newMessage);

    // Auto-resize textarea
    if (this.messageInput) {
      const textarea &#x3D; this.messageInput.nativeElement;
      textarea.style.height &#x3D; &#x27;auto&#x27;;
      textarea.style.height &#x3D; &#x60;${textarea.scrollHeight}px&#x60;;
    }
  }

  /**
   * Set up WebSocket listeners for real-time chat
   */
  setupSocketListeners(): void {
    this.chatService.connectSocket();

    // Create a subject that we can subscribe to and unsubscribe from
    const messageSubject &#x3D; new BehaviorSubject&lt;any&gt;(null);
    const typingSubject &#x3D; new BehaviorSubject&lt;any&gt;(null);

    // Set up the socket listener for new messages
    this.chatService.onNewMessage(message &#x3D;&gt; {
      messageSubject.next(message);
    });

    // Set up the socket listener for typing indicators
    this.chatService.onTypingIndicator(data &#x3D;&gt; {
      typingSubject.next(data);
    });

    // Subscribe to message subject
    const messageSub &#x3D; messageSubject.subscribe(message &#x3D;&gt; {
      if (!message) return; // Skip the initial null value

      // Update messages array if the message is for the current chat
      if (
        this.selectedContactId &amp;&amp;
        (message.sender.id &#x3D;&#x3D;&#x3D; this.selectedContactId ||
          (message.recipient &amp;&amp; message.recipient.id &#x3D;&#x3D;&#x3D; this.selectedContactId))
      ) {
        // Transform the message to match our format
        const formattedMessage &#x3D; this.transformMessages([message])[0];
        this.messages &#x3D; [...this.messages, formattedMessage];
        this.groupMessagesByDate();
        this.extractMediaFromMessages();

        // Mark as read if it&#x27;s from the selected contact
        if (message.sender.id &#x3D;&#x3D;&#x3D; this.selectedContactId) {
          this.markAsRead(message._id);
        }

        // Scroll to bottom
        this.shouldScrollToBottom &#x3D; true;
      }

      // Update the unread count for the contact
      if (message.sender &amp;&amp; message.sender.id) {
        this.incrementUnreadCount(message.sender.id);
      }
    });

    // Subscribe to typing indicator subject
    const typingSub &#x3D; typingSubject.subscribe(data &#x3D;&gt; {
      if (!data) return; // Skip the initial null value

      // Update typing indicator for the contact
      if (data.userId &amp;&amp; data.userId !&#x3D;&#x3D; this.currentUserId) {
        this.updateContactTypingStatus(data.userId, true);

        // Auto-reset typing status after 3 seconds
        setTimeout(() &#x3D;&gt; {
          this.updateContactTypingStatus(data.userId, false);
        }, 3000);
      }
    });

    this.subscriptions.push(messageSub, typingSub);
  }

  /**
   * Update typing status for a contact
   */
  updateContactTypingStatus(contactId: string, isTyping: boolean): void {
    this.contacts &#x3D; this.contacts.map(contact &#x3D;&gt; {
      if (contact.id &#x3D;&#x3D;&#x3D; contactId) {
        return {
          ...contact,
          typing: isTyping,
        };
      }
      return contact;
    });

    this.filterContacts();

    // Update UI typing indicator if this is the selected contact
    if (contactId &#x3D;&#x3D;&#x3D; this.selectedContactId) {
      this.isContactTyping &#x3D; isTyping;
    }
  }

  /**
   * Select a contact to chat with
   */
  selectContact(contactId: string): void {
    this.selectedContactId &#x3D; contactId;

    // Update URL without reloading
    this.router.navigate([&#x27;/chat&#x27;, contactId], { replaceUrl: true });

    // Load messages for this contact
    this.loadMessages();

    // Load message auto-deletion settings for this contact
    this.loadMessageAutoDeletionSettings();

    // Reset unread count for this contact
    this.resetUnreadCount(contactId);

    // Reset UI state
    this.replyingTo &#x3D; null;
    this.showEmojiPicker &#x3D; false;
    this.temporaryMessageMode &#x3D; false;
  }

  /**
   * Deselect the current contact (mobile view)
   */
  deselectContact(): void {
    this.selectedContactId &#x3D; null;
    this.router.navigate([&#x27;/chat&#x27;], { replaceUrl: true });
  }

  /**
   * Get a contact by ID
   */
  getContactById(contactId: string): Contact | undefined {
    return this.contacts.find(contact &#x3D;&gt; contact.id &#x3D;&#x3D;&#x3D; contactId);
  }

  /**
   * Get the currently selected contact
   */
  getSelectedContact(): Contact | undefined {
    return this.getContactById(this.selectedContactId);
  }

  /**
   * Check if the selected contact is pinned
   */
  isPinned(): boolean {
    const contact &#x3D; this.getSelectedContact();
    return contact?.pinned || false;
  }

  /**
   * Toggle pin status for the selected contact
   */
  togglePin(): void {
    if (this.selectedContactId) {
      this.contacts &#x3D; this.contacts.map(contact &#x3D;&gt; {
        if (contact.id &#x3D;&#x3D;&#x3D; this.selectedContactId) {
          return {
            ...contact,
            pinned: !contact.pinned,
          };
        }
        return contact;
      });

      this.filterContacts();

      // In a real app, you would save this to the server
      this.notificationService.success(
        this.isPinned() ? &#x27;Conversation pinned to the top&#x27; : &#x27;Conversation unpinned&#x27;
      );
    }
  }

  /**
   * Block a contact
   */
  blockContact(): void {
    if (this.selectedContactId) {
      // In a real app, you would call an API to block the contact
      this.notificationService.success(&#x27;Contact blocked&#x27;);

      // Remove from contacts list
      this.contacts &#x3D; this.contacts.filter(contact &#x3D;&gt; contact.id !&#x3D;&#x3D; this.selectedContactId);

      this.filterContacts();
      this.deselectContact();
    }
  }

  /**
   * Clear conversation history
   */
  clearConversation(): void {
    if (this.selectedContactId) {
      // In a real app, you would call an API to clear the conversation
      this.messages &#x3D; [];
      this.messageGroups &#x3D; [];
      this.galleryImages &#x3D; [];
      this.galleryFiles &#x3D; [];
      this.galleryLinks &#x3D; [];

      this.notificationService.success(&#x27;Conversation cleared&#x27;);
    }
  }

  /**
   * Mark a message as read
   */
  markAsRead(messageId: string): void {
    this.chatService.markAsRead(messageId).subscribe({
      next: () &#x3D;&gt; {
        // Update the message in our local array
        this.messages &#x3D; this.messages.map(msg &#x3D;&gt;
          msg._id &#x3D;&#x3D;&#x3D; messageId ? { ...msg, read: true } : msg
        );

        // Update message groups
        this.groupMessagesByDate();
      },
      error: err &#x3D;&gt; console.error(&#x27;Error marking message as read:&#x27;, err),
    });
  }

  /**
   * Mark all messages from the selected contact as read
   */
  markContactMessagesAsRead(): void {
    if (this.selectedContactId) {
      const unreadMessages &#x3D; this.messages.filter(
        msg &#x3D;&gt; msg.sender.id &#x3D;&#x3D;&#x3D; this.selectedContactId &amp;&amp; !msg.read
      );

      unreadMessages.forEach(msg &#x3D;&gt; {
        this.markAsRead(msg._id);
      });

      this.resetUnreadCount(this.selectedContactId);
    }
  }

  /**
   * Mark all messages as read
   */
  markAllAsRead(): void {
    this.contacts.forEach(contact &#x3D;&gt; {
      this.resetUnreadCount(contact.id);
    });

    this.notificationService.success(&#x27;All messages marked as read&#x27;);
  }

  /**
   * Archive all chats
   */
  archiveAllChats(): void {
    this.contacts &#x3D; this.contacts.map(contact &#x3D;&gt; ({
      ...contact,
      archived: true,
    }));

    this.filterContacts();
    this.notificationService.success(&#x27;All conversations archived&#x27;);
  }

  /**
   * Update the last message for a contact
   */
  updateContactLastMessage(contactId: string, message: string): void {
    this.contacts &#x3D; this.contacts.map(contact &#x3D;&gt; {
      if (contact.id &#x3D;&#x3D;&#x3D; contactId) {
        return {
          ...contact,
          lastMessage: message,
          lastMessageTime: new Date(),
        };
      }
      return contact;
    });

    this.filterContacts();
  }

  /**
   * Increment the unread count for a contact
   */
  incrementUnreadCount(contactId: string): void {
    if (contactId !&#x3D;&#x3D; this.selectedContactId) {
      this.contacts &#x3D; this.contacts.map(contact &#x3D;&gt; {
        if (contact.id &#x3D;&#x3D;&#x3D; contactId) {
          return {
            ...contact,
            unreadCount: contact.unreadCount + 1,
          };
        }
        return contact;
      });

      this.filterContacts();
    }
  }

  /**
   * Reset the unread count for a contact
   */
  resetUnreadCount(contactId: string): void {
    this.contacts &#x3D; this.contacts.map(contact &#x3D;&gt; {
      if (contact.id &#x3D;&#x3D;&#x3D; contactId) {
        return {
          ...contact,
          unreadCount: 0,
        };
      }
      return contact;
    });

    this.filterContacts();
  }

  /**
   * Filter contacts based on search term and current filter
   */
  filterContacts(): void {
    let filtered &#x3D; [...this.contacts];

    // Apply search filter
    if (this.searchTerm) {
      const search &#x3D; this.searchTerm.toLowerCase();
      filtered &#x3D; filtered.filter(
        contact &#x3D;&gt;
          contact.name.toLowerCase().includes(search) ||
          contact.lastMessage.toLowerCase().includes(search)
      );
    }

    // Apply current filter
    if (this.currentFilter &#x3D;&#x3D;&#x3D; &#x27;unread&#x27;) {
      filtered &#x3D; filtered.filter(contact &#x3D;&gt; contact.unreadCount &gt; 0);
    } else if (this.currentFilter &#x3D;&#x3D;&#x3D; &#x27;archived&#x27;) {
      filtered &#x3D; filtered.filter(contact &#x3D;&gt; contact.archived);
    } else if (this.currentFilter &#x3D;&#x3D;&#x3D; &#x27;all&#x27;) {
      filtered &#x3D; filtered.filter(contact &#x3D;&gt; !contact.archived);
    }

    // Sort: pinned first, then by last message time
    filtered.sort((a, b) &#x3D;&gt; {
      if (a.pinned &amp;&amp; !b.pinned) return -1;
      if (!a.pinned &amp;&amp; b.pinned) return 1;
      return b.lastMessageTime.getTime() - a.lastMessageTime.getTime();
    });

    this.filteredContacts &#x3D; filtered;
  }

  /**
   * Filter conversations by type
   */
  filterConversations(filter: &#x27;all&#x27; | &#x27;unread&#x27; | &#x27;archived&#x27;): void {
    this.currentFilter &#x3D; filter;
    this.filterContacts();
  }

  /**
   * Toggle notifications for the chat
   */
  toggleNotifications(): void {
    this.notificationsEnabled &#x3D; !this.notificationsEnabled;
    this.notificationService.info(
      this.notificationsEnabled ? &#x27;Notifications enabled&#x27; : &#x27;Notifications muted&#x27;
    );
  }

  /**
   * Format message content with links and emojis
   */
  formatMessageContent(content: string): string {
    // Convert URLs to links
    const urlRegex &#x3D; /(https?:\/\/[^\s]+)/g;
    let formattedContent &#x3D; content.replace(urlRegex, &#x27;&lt;a href&#x3D;&quot;$1&quot; target&#x3D;&quot;_blank&quot;&gt;$1&lt;/a&gt;&#x27;);

    // Escape HTML except for the links we just added
    formattedContent &#x3D; formattedContent
      .replace(/&amp;/g, &#x27;&amp;amp;&#x27;)
      .replace(/&lt;/g, &#x27;&amp;lt;&#x27;)
      .replace(/&gt;/g, &#x27;&amp;gt;&#x27;)
      .replace(
        /&amp;lt;a href&#x3D;&quot;(.*?)&quot; target&#x3D;&quot;_blank&quot;&amp;gt;(.*?)&amp;lt;\/a&amp;gt;/g,
        &#x27;&lt;a href&#x3D;&quot;$1&quot; target&#x3D;&quot;_blank&quot;&gt;$2&lt;/a&gt;&#x27;
      );

    return formattedContent;
  }

  /**
   * Check if an attachment is an image
   */
  isImageAttachment(attachment: Attachment): boolean {
    return attachment.type.startsWith(&#x27;image/&#x27;);
  }

  /**
   * Get the appropriate icon for a file type
   */
  getFileIcon(file: Attachment): string {
    const type &#x3D; file.type.toLowerCase();

    if (type.includes(&#x27;pdf&#x27;)) return &#x27;picture_as_pdf&#x27;;
    if (type.includes(&#x27;word&#x27;) || type.includes(&#x27;document&#x27;)) return &#x27;description&#x27;;
    if (type.includes(&#x27;excel&#x27;) || type.includes(&#x27;sheet&#x27;)) return &#x27;table_chart&#x27;;
    if (type.includes(&#x27;powerpoint&#x27;) || type.includes(&#x27;presentation&#x27;)) return &#x27;slideshow&#x27;;
    if (type.includes(&#x27;zip&#x27;) || type.includes(&#x27;rar&#x27;) || type.includes(&#x27;tar&#x27;)) return &#x27;archive&#x27;;
    if (type.includes(&#x27;audio&#x27;)) return &#x27;audio_file&#x27;;
    if (type.includes(&#x27;video&#x27;)) return &#x27;video_file&#x27;;

    return &#x27;insert_drive_file&#x27;;
  }

  /**
   * Format file size for display
   */
  formatFileSize(bytes: number): string {
    if (bytes &#x3D;&#x3D;&#x3D; 0) return &#x27;0 Bytes&#x27;;

    const k &#x3D; 1024;
    const sizes &#x3D; [&#x27;Bytes&#x27;, &#x27;KB&#x27;, &#x27;MB&#x27;, &#x27;GB&#x27;];
    const i &#x3D; Math.floor(Math.log(bytes) / Math.log(k));

    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + &#x27; &#x27; + sizes[i];
  }

  /**
   * Reply to a message
   */
  replyToMessage(message: ChatMessage): void {
    this.replyingTo &#x3D; message;

    // Focus on the message input
    setTimeout(() &#x3D;&gt; {
      if (this.messageInput) {
        this.messageInput.nativeElement.focus();
      }
    }, 0);
  }

  /**
   * Cancel replying to a message
   */
  cancelReply(): void {
    this.replyingTo &#x3D; null;
  }

  /**
   * Forward a message to another contact
   */
  forwardMessage(message: ChatMessage): void {
    // Open new message dialog
    const dialogRef &#x3D; this.dialog.open(this.newMessageDialog);

    // Store the message to forward
    const messageToForward &#x3D; message;

    // When a contact is selected, forward the message
    dialogRef.afterClosed().subscribe(result &#x3D;&gt; {
      if (result) {
        // In a real app, you would call an API to forward the message
        this.notificationService.success(&#x27;Message forwarded&#x27;);
      }
    });
  }

  /**
   * Copy a message to clipboard
   */
  copyMessage(message: ChatMessage): void {
    navigator.clipboard
      .writeText(message.message)
      .then(() &#x3D;&gt; {
        this.notificationService.success(&#x27;Message copied to clipboard&#x27;);
      })
      .catch(err &#x3D;&gt; {
        console.error(&#x27;Error copying message:&#x27;, err);
        this.notificationService.error(&#x27;Failed to copy message&#x27;);
      });
  }

  /**
   * Delete a message
   */
  deleteMessage(message: ChatMessage): void {
    // In a real app, you would call an API to delete the message
    this.messages &#x3D; this.messages.filter(msg &#x3D;&gt; msg._id !&#x3D;&#x3D; message._id);
    this.groupMessagesByDate();
    this.extractMediaFromMessages();

    this.notificationService.success(&#x27;Message deleted&#x27;);
  }

  /**
   * Truncate a message for display in the reply preview
   */
  truncateMessage(message: string, maxLength &#x3D; 50): string {
    if (message.length &lt;&#x3D; maxLength) return message;
    return message.substring(0, maxLength) + &#x27;...&#x27;;
  }

  /**
   * Scroll to the bottom of the message list
   */
  scrollToBottom(): void {
    if (this.messageList) {
      const element &#x3D; this.messageList.nativeElement;
      element.scrollTop &#x3D; element.scrollHeight;
    }
  }

  /**
   * Toggle the emoji picker
   */
  toggleEmojiPicker(): void {
    this.showEmojiPicker &#x3D; !this.showEmojiPicker;
  }

  /**
   * Select an emoji category
   */
  selectEmojiCategory(category: EmojiCategory): void {
    this.currentCategoryEmojis &#x3D; category.emojis;
  }

  /**
   * Add an emoji to the message input
   */
  addEmoji(emoji: string): void {
    this.newMessage +&#x3D; emoji;

    // Focus back on the input
    if (this.messageInput) {
      this.messageInput.nativeElement.focus();
    }
  }

  /**
   * Open the attachment menu
   */
  openAttachmentMenu(): void {
    // In a real app, you would open a file picker or menu
    // For now, we&#x27;ll just show a notification
    this.notificationService.info(&#x27;Attachment feature coming soon&#x27;);

    // When implementing file uploads, make sure to handle temporary messages:
    // 1. Check if temporaryMessageMode is enabled
    // 2. If enabled, use the temporaryMessageTTL value for the attachment TTL
    // 3. Use chatService.convertHoursToMilliseconds(this.temporaryMessageTTL) to convert to milliseconds
    // 4. Pass the TTL to the chatService.sendMessageWithAttachments method
  }

  /**
   * Open the new message dialog
   */
  openNewMessageDialog(): void {
    this.newMessageSearch &#x3D; &#x27;&#x27;;
    this.filteredNewMessageContacts &#x3D; [...this.contacts];

    const dialogRef &#x3D; this.dialog.open(this.newMessageDialog);

    dialogRef.afterClosed().subscribe(result &#x3D;&gt; {
      if (result) {
        // Handle result if needed
      }
    });
  }

  /**
   * Select a contact from the new message dialog
   */
  selectNewMessageContact(contact: Contact): void {
    this.dialog.closeAll();
    this.selectContact(contact.id);
  }

  /**
   * Open image preview dialog
   */
  openImagePreview(image: Attachment): void {
    this.previewImage &#x3D; image;

    this.dialog.open(this.imagePreviewDialog, {
      maxWidth: &#x27;90vw&#x27;,
      maxHeight: &#x27;90vh&#x27;,
      panelClass: &#x27;image-preview-dialog&#x27;,
    });
  }

  /**
   * Download an image from the preview
   */
  downloadImage(): void {
    if (this.previewImage) {
      this.downloadAttachment(this.previewImage);
    }
  }

  /**
   * Share an image from the preview
   */
  shareImage(): void {
    if (this.previewImage &amp;&amp; navigator.share) {
      navigator
        .share({
          title: this.previewImage.name,
          url: this.previewImage.url,
        })
        .catch(err &#x3D;&gt; {
          console.error(&#x27;Error sharing image:&#x27;, err);
        });
    } else {
      this.notificationService.info(&#x27;Sharing not supported on this device&#x27;);
    }
  }

  /**
   * Download an attachment
   */
  downloadAttachment(attachment: Attachment): void {
    // Create a link element and trigger download
    const link &#x3D; document.createElement(&#x27;a&#x27;);
    link.href &#x3D; attachment.url;
    link.download &#x3D; attachment.name;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
  }

  /**
   * Open the search in chat dialog
   */
  openSearchInChat(): void {
    this.chatSearchQuery &#x3D; &#x27;&#x27;;
    this.chatSearchResults &#x3D; [];

    this.dialog.open(this.searchInChatDialog);
  }

  /**
   * Highlight search text in results
   */
  highlightSearchText(text: string): string {
    if (!this.chatSearchQuery) return text;

    const regex &#x3D; new RegExp(&#x60;(${this.chatSearchQuery})&#x60;, &#x27;gi&#x27;);
    return text.replace(regex, &#x27;&lt;mark&gt;$1&lt;/mark&gt;&#x27;);
  }

  /**
   * Scroll to a specific message
   */
  scrollToMessage(message: ChatMessage): void {
    this.dialog.closeAll();

    // Find the message element and scroll to it
    setTimeout(() &#x3D;&gt; {
      const messageId &#x3D; message._id;
      const messageElement &#x3D; document.getElementById(&#x60;message-${messageId}&#x60;);

      if (messageElement) {
        messageElement.scrollIntoView({ behavior: &#x27;smooth&#x27;, block: &#x27;center&#x27; });
        messageElement.classList.add(&#x27;highlight&#x27;);

        // Remove highlight after animation
        setTimeout(() &#x3D;&gt; {
          messageElement.classList.remove(&#x27;highlight&#x27;);
        }, 2000);
      }
    }, 100);
  }

  /**
   * Open the media gallery dialog
   */
  openMediaGallery(): void {
    this.galleryTab &#x3D; &#x27;images&#x27;;

    this.dialog.open(this.mediaGalleryDialog, {
      width: &#x27;80vw&#x27;,
      maxWidth: &#x27;800px&#x27;,
      maxHeight: &#x27;80vh&#x27;,
    });
  }

  /**
   * Open a link in a new tab
   */
  openLink(url: string): void {
    window.open(url, &#x27;_blank&#x27;);
  }

  /**
   * View the selected contact&#x27;s profile
   */
  viewContactProfile(): void {
    if (this.selectedContactId) {
      // In a real app, you would navigate to the contact&#x27;s profile
      this.notificationService.info(&#x27;Profile view coming soon&#x27;);
    }
  }

  /**
   * Get a random profile image for demo purposes
   */
  private getRandomProfileImage(): string {
    const images &#x3D; [
      &#x27;/assets/img/profile1.jpg&#x27;,
      &#x27;/assets/img/profile2.jpg&#x27;,
      &#x27;/assets/img/profile3.jpg&#x27;,
      &#x27;/assets/img/profile4.jpg&#x27;,
      &#x27;/assets/img/default-profile.jpg&#x27;,
    ];

    return images[Math.floor(Math.random() * images.length)];
  }

  /**
   * Create dummy messages for demo purposes
   */
  private createDummyMessages(contact: Contact): void {
    const now &#x3D; new Date();
    const yesterday &#x3D; new Date(now);
    yesterday.setDate(yesterday.getDate() - 1);

    // Create messages from different days for testing date separators
    this.messages &#x3D; [
      // Yesterday
      {
        _id: &#x27;1&#x27;,
        sender: {
          id: contact.id,
          username: contact.name,
        },
        message: &#x27;Hey there! How are you?&#x27;,
        timestamp: new Date(yesterday.setHours(10, 30)),
        read: true,
      },
      {
        _id: &#x27;2&#x27;,
        sender: {
          id: this.currentUserId,
          username: &#x27;You&#x27;,
        },
        message: &quot;I&#x27;m doing great! How about you?&quot;,
        timestamp: new Date(yesterday.setHours(10, 35)),
        read: true,
      },
      {
        _id: &#x27;3&#x27;,
        sender: {
          id: contact.id,
          username: contact.name,
        },
        message: &#x27;Pretty good, thanks for asking! What are you up to this weekend?&#x27;,
        timestamp: new Date(yesterday.setHours(10, 40)),
        read: true,
      },

      // Today
      {
        _id: &#x27;4&#x27;,
        sender: {
          id: this.currentUserId,
          username: &#x27;You&#x27;,
        },
        message: &quot;I&#x27;m planning to go hiking, weather permitting. Want to join?&quot;,
        timestamp: new Date(now.setHours(9, 15)),
        read: true,
      },
      {
        _id: &#x27;5&#x27;,
        sender: {
          id: contact.id,
          username: contact.name,
        },
        message: &#x27;That sounds fun! Where are you thinking of going?&#x27;,
        timestamp: new Date(now.setHours(9, 20)),
        read: true,
      },
      {
        _id: &#x27;6&#x27;,
        sender: {
          id: this.currentUserId,
          username: &#x27;You&#x27;,
        },
        message:
          &quot;I was thinking of trying the new trail at Mount Rainier. It&#x27;s supposed to have amazing views!&quot;,
        timestamp: new Date(now.setHours(9, 25)),
        read: true,
      },
      {
        _id: &#x27;7&#x27;,
        sender: {
          id: contact.id,
          username: contact.name,
        },
        message: &#x27;Check out this photo from my last hike there:&#x27;,
        timestamp: new Date(now.setHours(9, 30)),
        read: true,
        attachments: [
          {
            id: &#x27;img1&#x27;,
            name: &#x27;mountain.jpg&#x27;,
            type: &#x27;image/jpeg&#x27;,
            size: 1024 * 1024 * 2.5, // 2.5MB
            url: &#x27;https://images.unsplash.com/photo-1464822759023-fed622ff2c3b&#x27;,
            timestamp: new Date(now.setHours(9, 30)),
          },
        ],
      },
      {
        _id: &#x27;8&#x27;,
        sender: {
          id: this.currentUserId,
          username: &#x27;You&#x27;,
        },
        message: &#x27;Wow, that looks amazing! 😍&#x27;,
        timestamp: new Date(now.setHours(9, 32)),
        read: true,
      },
      {
        _id: &#x27;9&#x27;,
        sender: {
          id: contact.id,
          username: contact.name,
        },
        message:
          &quot;Here&#x27;s the trail map I used: https://www.alltrails.com/trail/us/washington/mount-rainier&quot;,
        timestamp: new Date(now.setHours(9, 35)),
        read: true,
      },
      {
        _id: &#x27;10&#x27;,
        sender: {
          id: contact.id,
          username: contact.name,
        },
        message: &#x27;And I also have the PDF guide if you want it:&#x27;,
        timestamp: new Date(now.setHours(9, 36)),
        read: true,
        attachments: [
          {
            id: &#x27;file1&#x27;,
            name: &#x27;Rainier_Trail_Guide.pdf&#x27;,
            type: &#x27;application/pdf&#x27;,
            size: 1024 * 1024 * 1.2, // 1.2MB
            url: &#x27;#&#x27;,
            timestamp: new Date(now.setHours(9, 36)),
          },
        ],
      },
      {
        _id: &#x27;11&#x27;,
        sender: {
          id: this.currentUserId,
          username: &#x27;You&#x27;,
        },
        message:
          &quot;Thanks! This is super helpful. I&#x27;ll check it out and let you know if I have any questions.&quot;,
        timestamp: new Date(now.setHours(9, 40)),
        read: true,
      },
      {
        _id: &#x27;12&#x27;,
        sender: {
          id: contact.id,
          username: contact.name,
        },
        message: contact.lastMessage,
        timestamp: contact.lastMessageTime,
        read: contact.unreadCount &#x3D;&#x3D;&#x3D; 0,
      },
    ];
  }
}
</code></pre>
    </div>
</div>








                   </div><div class="search-results">
    <div class="has-results">
        <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
        <ul class="search-results-list"></ul>
    </div>
    <div class="no-results">
        <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
    </div>
</div>
</div>
               <!-- END CONTENT -->
           </div>
       </div>

          <label class="dark-mode-switch">
               <input type="checkbox">
               <span class="slider">
                    <svg class="slider-icon" viewBox="0 0 24 24" fill="none" height="20" stroke="#000" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" width="20" xmlns="http://www.w3.org/2000/svg">
                    <path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"></path>
                    </svg>
               </span>
          </label>

       <script>
            var COMPODOC_CURRENT_PAGE_DEPTH = 1;
            var COMPODOC_CURRENT_PAGE_CONTEXT = 'interface';
            var COMPODOC_CURRENT_PAGE_URL = 'Attachment-1.html';
            var MAX_SEARCH_RESULTS = 15;
       </script>

       <script>
               $darkModeToggleSwitchers = document.querySelectorAll('.dark-mode-switch input');
               checkToggle(darkModeState);
               if ($darkModeToggleSwitchers.length > 0) {
                    for (var i = 0; i < $darkModeToggleSwitchers.length; i++) {
                         $darkModeToggleSwitchers[i].addEventListener('change', function (event) {
                              darkModeState = !darkModeState;
                              toggleDarkMode(darkModeState);
                         });
                    }
               }
          </script>

       <script src="../js/libs/custom-elements.min.js"></script>
       <script src="../js/libs/lit-html.js"></script>

       <script src="../js/menu-wc.js" defer></script>
       <script nomodule src="../js/menu-wc_es5.js" defer></script>

       <script src="../js/libs/bootstrap-native.js"></script>

       <script src="../js/libs/es6-shim.min.js"></script>
       <script src="../js/libs/EventDispatcher.js"></script>
       <script src="../js/libs/promise.min.js"></script>

       <script src="../js/compodoc.js"></script>

       <script src="../js/tabs.js"></script>
       <script src="../js/menu.js"></script>
       <script src="../js/libs/clipboard.min.js"></script>
       <script src="../js/libs/prism.js"></script>
       <script src="../js/sourceCode.js"></script>
          <script src="../js/search/search.js"></script>
          <script src="../js/search/lunr.min.js"></script>
          <script src="../js/search/search-lunr.js"></script>
          <script src="../js/search/search_index.js"></script>
       <script src="../js/lazy-load-graphs.js"></script>


    </body>
</html>
