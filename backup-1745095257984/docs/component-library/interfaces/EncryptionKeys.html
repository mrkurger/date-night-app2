<!doctype html>
<html class="no-js" lang="">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <title>client-angular documentation</title>
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <link rel="icon" type="image/x-icon" href="../images/favicon.ico">
	   <link rel="stylesheet" href="../styles/style.css">
        <link rel="stylesheet" href="../styles/dark.css">
    </head>
    <body>
          <script>
               // Blocking script to avoid flickering dark mode
               // Dark mode toggle button
               var useDark = window.matchMedia('(prefers-color-scheme: dark)');
               var darkModeState = useDark.matches;
               var $darkModeToggleSwitchers = document.querySelectorAll('.dark-mode-switch input');
               var $darkModeToggles = document.querySelectorAll('.dark-mode-switch');
               var darkModeStateLocal = localStorage.getItem('compodoc_darkmode-state');

               function checkToggle(check) {
                    for (var i = 0; i < $darkModeToggleSwitchers.length; i++) {
                         $darkModeToggleSwitchers[i].checked = check;
                    }
               }

               function toggleDarkMode(state) {
                    if (window.localStorage) {
                         localStorage.setItem('compodoc_darkmode-state', state);
                    }

                    checkToggle(state);

                    const hasClass = document.body.classList.contains('dark');

                    if (state) {
                         for (var i = 0; i < $darkModeToggles.length; i++) {
                              $darkModeToggles[i].classList.add('dark');
                         }
                         if (!hasClass) {
                              document.body.classList.add('dark');
                         }
                    } else {
                         for (var i = 0; i < $darkModeToggles.length; i++) {
                              $darkModeToggles[i].classList.remove('dark');
                         }
                         if (hasClass) {
                              document.body.classList.remove('dark');
                         }
                    }
               }

               useDark.addEventListener('change', function (evt) {
                    toggleDarkMode(evt.matches);
               });
               if (darkModeStateLocal) {
                    darkModeState = darkModeStateLocal === 'true';
               }
               toggleDarkMode(darkModeState);
          </script>

        <div class="navbar navbar-default navbar-fixed-top d-md-none p-0">
               <div class="d-flex">
                    <a href="../" class="navbar-brand">client-angular documentation</a>
                    <button type="button" class="btn btn-default btn-menu ion-ios-menu" id="btn-menu"></button>
               </div>
        </div>

        <div class="xs-menu menu" id="mobile-menu">
                <div id="book-search-input" role="search"><input type="text" placeholder="Type to search"></div>            <compodoc-menu></compodoc-menu>
        </div>

        <div class="container-fluid main">
           <div class="row main">
               <div class="d-none d-md-block menu">
                   <compodoc-menu mode="normal"></compodoc-menu>
               </div>
               <!-- START CONTENT -->
               <div class="content interface">
                   <div class="content-data">













<ol class="breadcrumb">
  <li class="breadcrumb-item">Interfaces</li>
  <li class="breadcrumb-item"
  >
  EncryptionKeys</li>
</ol>

<ul class="nav nav-tabs" role="tablist">
        <li class="nav-item">
            <a href="#info" 
                class="nav-link"
                class="nav-link active"
                role="tab" id="info-tab" data-bs-toggle="tab" data-link="info">Info</a>
        </li>
        <li class="nav-item">
            <a href="#source" 
                class="nav-link"
                
                role="tab" id="source-tab" data-bs-toggle="tab" data-link="source">Source</a>
        </li>
</ul>

<div class="tab-content">
    <div class="tab-pane fade active in" id="info">
        <p class="comment">
            <h3>File</h3>
        </p>
        <p class="comment">
            <code>src/app/core/services/encryption.service.ts</code>
        </p>




        <section data-compodoc="block-index">
            <h3 id="index">Index</h3>
            <table class="table table-sm table-bordered index-table">
                <tbody>
                    <tr>
                        <td class="col-md-4">
                            <h6><b>Properties</b></h6>
                        </td>
                    </tr>
                    <tr>
                        <td class="col-md-4">
                            <ul class="index-list">
                                <li>
                                        <a href="#privateKey" 
>
                                            privateKey
                                        </a>
                                </li>
                                <li>
                                        <a href="#publicKey" 
>
                                            publicKey
                                        </a>
                                </li>
                            </ul>
                        </td>
                    </tr>
                </tbody>
            </table>
        </section>



            <section data-compodoc="block-properties">
                <h3 id="inputs">Properties</h3>
                    <table class="table table-sm table-bordered">
                        <tbody>
                                <tr>
                                    <td class="col-md-4">
                                        <a name="privateKey"></a>
                                        <span class="name "><b>privateKey</b>
                                            <a href="#privateKey">
                                                <span class="icon ion-ios-link"></span>
                                            </a>
                                        </span>
                                    </td>
                                </tr>
                                <tr>
                                    <td class="col-md-4">
                                        <code>privateKey:         <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/string" target="_blank" >string</a></code>
</code>
                                    </td>
                                </tr>


                                    <tr>
                                        <td class="col-md-4">
                                            <i>Type : </i>        <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/string" target="_blank" >string</a></code>

                                        </td>
                                    </tr>





                        </tbody>
                    </table>
                    <table class="table table-sm table-bordered">
                        <tbody>
                                <tr>
                                    <td class="col-md-4">
                                        <a name="publicKey"></a>
                                        <span class="name "><b>publicKey</b>
                                            <a href="#publicKey">
                                                <span class="icon ion-ios-link"></span>
                                            </a>
                                        </span>
                                    </td>
                                </tr>
                                <tr>
                                    <td class="col-md-4">
                                        <code>publicKey:         <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/string" target="_blank" >string</a></code>
</code>
                                    </td>
                                </tr>


                                    <tr>
                                        <td class="col-md-4">
                                            <i>Type : </i>        <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/string" target="_blank" >string</a></code>

                                        </td>
                                    </tr>





                        </tbody>
                    </table>
            </section>
    </div>


    <div class="tab-pane fade  tab-source-code" id="source">
        <pre class="line-numbers compodoc-sourcecode"><code class="language-typescript">import { Injectable } from &#x27;@angular/core&#x27;;
import { HttpClient } from &#x27;@angular/common/http&#x27;;
import { Observable, from, of, timer } from &#x27;rxjs&#x27;;
import { map, catchError, switchMap, takeUntil } from &#x27;rxjs/operators&#x27;;
import { environment } from &#x27;../../../environments/environment&#x27;;
import { AuthService } from &#x27;./auth.service&#x27;;

// Constants
const KEY_STORAGE_PREFIX &#x3D; &#x27;chat_keys_&#x27;;
const ENABLE_ENCRYPTION &#x3D; true;
const KEY_PAIR_ALGORITHM &#x3D; &#x27;RSA-OAEP&#x27;;
const SYMMETRIC_ALGORITHM &#x3D; &#x27;AES-GCM&#x27;;
const MESSAGE_AUTO_DELETION &#x3D; true;
const DEFAULT_MESSAGE_TTL &#x3D; 7 * 24 * 60 * 60 * 1000; // 7 days in milliseconds

export interface EncryptionKeys {
  publicKey: string;
  privateKey: string;
}

export interface EncryptedData {
  ciphertext: string;
  iv: string;
  authTag?: string;
  expiresAt?: number; // Timestamp when the message should expire
}

export interface RoomKeys {
  roomId: string;
  symmetricKey: string;
  encryptedSymmetricKey: string;
  publicKeys: { [userId: string]: string };
}

export interface MessageExpirySettings {
  enabled: boolean;
  ttl: number; // Time-to-live in milliseconds
}

@Injectable({
  providedIn: &#x27;root&#x27;,
})
export class EncryptionService {
  private readonly apiUrl &#x3D; environment.apiUrl + &#x27;/chat/encryption&#x27;;
  private keyPair: CryptoKeyPair | null &#x3D; null;
  private roomKeys: Map&lt;string, CryptoKey&gt; &#x3D; new Map();
  private isInitialized &#x3D; false;
  private messageExpirySettings: Map&lt;string, MessageExpirySettings&gt; &#x3D; new Map(); // Room-specific expiry settings
  private defaultExpirySettings: MessageExpirySettings &#x3D; {
    enabled: MESSAGE_AUTO_DELETION,
    ttl: DEFAULT_MESSAGE_TTL,
  };

  constructor(
    private http: HttpClient,
    private authService: AuthService
  ) {}

  /**
   * Initialize the encryption service
   * This should be called when the user logs in
   */
  async initialize(): Promise&lt;boolean&gt; {
    if (!ENABLE_ENCRYPTION) {
      console.log(&#x27;Encryption is disabled&#x27;);
      return false;
    }

    if (this.isInitialized) {
      return true;
    }

    try {
      // Check if we have keys in storage
      const userId &#x3D; this.authService.getCurrentUserId();
      if (!userId) {
        console.error(&#x27;User ID not available&#x27;);
        return false;
      }

      // Load user&#x27;s key pair
      const storedKeys &#x3D; this.getKeysFromStorage(userId);
      if (storedKeys) {
        // Import the stored keys
        this.keyPair &#x3D; await this.importKeyPair(storedKeys);
      } else {
        // Generate new keys if none exist
        console.log(&#x27;Generating new encryption keys for user&#x27;);
        this.keyPair &#x3D; await this.generateKeyPair();

        // Export and store the keys
        const exportedKeys &#x3D; await this.exportKeyPair(this.keyPair);
        this.storeKeys(userId, exportedKeys);

        // Register public key with the server
        await this.registerPublicKey(exportedKeys.publicKey);
      }

      // Load room keys from localStorage
      await this.loadStoredRoomKeys();

      // Load message expiry settings
      this.loadExpirySettings();

      // Start the message expiry checker if auto-deletion is enabled
      if (MESSAGE_AUTO_DELETION) {
        this.startMessageExpiryChecker();
      }

      this.isInitialized &#x3D; true;
      console.log(&#x27;Encryption service initialized successfully&#x27;);
      return true;
    } catch (error) {
      console.error(&#x27;Error initializing encryption service:&#x27;, error);
      return false;
    }
  }

  /**
   * Load all message expiry settings from localStorage
   */
  private loadExpirySettings(): void {
    const userId &#x3D; this.authService.getCurrentUserId();
    if (!userId) return;

    try {
      const key &#x3D; &#x60;${KEY_STORAGE_PREFIX}${userId}_expiry_settings&#x60;;
      const storedSettings &#x3D; localStorage.getItem(key);
      if (!storedSettings) return;

      const settingsMap &#x3D; JSON.parse(storedSettings);

      // Load settings into memory
      Object.entries(settingsMap).forEach(([roomId, settings]) &#x3D;&gt; {
        this.messageExpirySettings.set(roomId, settings as MessageExpirySettings);
      });

      console.log(&#x60;Loaded expiry settings for ${this.messageExpirySettings.size} rooms&#x60;);
    } catch (error) {
      console.error(&#x27;Error loading message expiry settings:&#x27;, error);
    }
  }

  /**
   * Start the periodic checker for expired messages
   * This runs every minute to check for and delete expired messages
   */
  private startMessageExpiryChecker(): void {
    // Check for expired messages every minute
    const checkInterval &#x3D; 60 * 1000; // 1 minute

    // Set up interval to check for expired messages
    setInterval(() &#x3D;&gt; {
      this.checkAndDeleteExpiredMessages();
    }, checkInterval);

    console.log(&#x27;Message expiry checker started&#x27;);
  }

  /**
   * Check for and delete expired messages
   */
  async checkAndDeleteExpiredMessages(): Promise&lt;void&gt; {
    if (!this.isEncryptionAvailable()) return;

    try {
      // Get all rooms with messages
      const rooms &#x3D; await this.http.get&lt;string[]&gt;(&#x60;${this.apiUrl}/rooms-with-messages&#x60;).toPromise();

      if (!rooms || rooms.length &#x3D;&#x3D;&#x3D; 0) return;

      const now &#x3D; Date.now();

      // Check each room for expired messages
      for (const roomId of rooms) {
        // Get expiry settings for this room
        const settings &#x3D; this.getMessageExpirySettings(roomId);

        // Skip if auto-deletion is disabled for this room
        if (!settings.enabled) continue;

        // Get expired messages for this room
        const expiredMessages &#x3D; await this.http
          .get&lt;string[]&gt;(&#x60;${this.apiUrl}/expired-messages/${roomId}?timestamp&#x3D;${now}&#x60;)
          .toPromise();

        if (!expiredMessages || expiredMessages.length &#x3D;&#x3D;&#x3D; 0) continue;

        console.log(&#x60;Found ${expiredMessages.length} expired messages in room ${roomId}&#x60;);

        // Delete expired messages
        await this.http
          .post(&#x60;${this.apiUrl}/delete-messages&#x60;, { messageIds: expiredMessages })
          .toPromise();

        console.log(&#x60;Deleted ${expiredMessages.length} expired messages from room ${roomId}&#x60;);
      }
    } catch (error) {
      console.error(&#x27;Error checking for expired messages:&#x27;, error);
    }
  }

  /**
   * Load all stored room keys from localStorage into memory
   */
  private async loadStoredRoomKeys(): Promise&lt;void&gt; {
    const userId &#x3D; this.authService.getCurrentUserId();
    if (!userId) {
      return;
    }

    try {
      const roomKeysKey &#x3D; &#x60;${KEY_STORAGE_PREFIX}${userId}_rooms&#x60;;
      const storedKeys &#x3D; localStorage.getItem(roomKeysKey);
      if (!storedKeys) {
        return;
      }

      const roomKeysMap &#x3D; JSON.parse(storedKeys);
      const roomIds &#x3D; Object.keys(roomKeysMap);

      console.log(&#x60;Loading ${roomIds.length} stored room keys&#x60;);

      for (const roomId of roomIds) {
        try {
          const keyBase64 &#x3D; roomKeysMap[roomId];
          if (!keyBase64) continue;

          // Import the symmetric key
          const symmetricKey &#x3D; await window.crypto.subtle.importKey(
            &#x27;raw&#x27;,
            this.base64ToArrayBuffer(keyBase64),
            {
              name: SYMMETRIC_ALGORITHM,
              length: 256,
            },
            true,
            [&#x27;encrypt&#x27;, &#x27;decrypt&#x27;]
          );

          // Store in memory
          this.roomKeys.set(roomId, symmetricKey);
        } catch (importError) {
          console.error(&#x60;Error importing stored key for room ${roomId}:&#x60;, importError);
          // Continue with other keys
        }
      }

      console.log(&#x60;Successfully loaded ${this.roomKeys.size} room keys&#x60;);
    } catch (error) {
      console.error(&#x27;Error loading stored room keys:&#x27;, error);
    }
  }

  /**
   * Check if encryption is enabled and initialized
   */
  isEncryptionAvailable(): boolean {
    return ENABLE_ENCRYPTION &amp;&amp; this.isInitialized;
  }

  /**
   * Generate a new key pair for asymmetric encryption
   */
  private async generateKeyPair(): Promise&lt;CryptoKeyPair&gt; {
    return window.crypto.subtle.generateKey(
      {
        name: KEY_PAIR_ALGORITHM,
        modulusLength: 2048,
        publicExponent: new Uint8Array([1, 0, 1]),
        hash: &#x27;SHA-256&#x27;,
      },
      true, // extractable
      [&#x27;encrypt&#x27;, &#x27;decrypt&#x27;]
    );
  }

  /**
   * Export a key pair to string format
   */
  private async exportKeyPair(keyPair: CryptoKeyPair): Promise&lt;EncryptionKeys&gt; {
    const publicKeyBuffer &#x3D; await window.crypto.subtle.exportKey(&#x27;spki&#x27;, keyPair.publicKey);
    const privateKeyBuffer &#x3D; await window.crypto.subtle.exportKey(&#x27;pkcs8&#x27;, keyPair.privateKey);

    return {
      publicKey: this.arrayBufferToBase64(publicKeyBuffer),
      privateKey: this.arrayBufferToBase64(privateKeyBuffer),
    };
  }

  /**
   * Import a key pair from string format
   */
  private async importKeyPair(keys: EncryptionKeys): Promise&lt;CryptoKeyPair&gt; {
    const publicKeyBuffer &#x3D; this.base64ToArrayBuffer(keys.publicKey);
    const privateKeyBuffer &#x3D; this.base64ToArrayBuffer(keys.privateKey);

    const publicKey &#x3D; await window.crypto.subtle.importKey(
      &#x27;spki&#x27;,
      publicKeyBuffer,
      {
        name: KEY_PAIR_ALGORITHM,
        hash: &#x27;SHA-256&#x27;,
      },
      true,
      [&#x27;encrypt&#x27;]
    );

    const privateKey &#x3D; await window.crypto.subtle.importKey(
      &#x27;pkcs8&#x27;,
      privateKeyBuffer,
      {
        name: KEY_PAIR_ALGORITHM,
        hash: &#x27;SHA-256&#x27;,
      },
      true,
      [&#x27;decrypt&#x27;]
    );

    return { publicKey, privateKey };
  }

  /**
   * Store encryption keys in localStorage
   */
  private storeKeys(userId: string, keys: EncryptionKeys): void {
    localStorage.setItem(&#x60;${KEY_STORAGE_PREFIX}${userId}&#x60;, JSON.stringify(keys));
  }

  /**
   * Get encryption keys from localStorage
   */
  private getKeysFromStorage(userId: string): EncryptionKeys | null {
    const storedKeys &#x3D; localStorage.getItem(&#x60;${KEY_STORAGE_PREFIX}${userId}&#x60;);
    if (!storedKeys) {
      return null;
    }

    try {
      return JSON.parse(storedKeys) as EncryptionKeys;
    } catch (error) {
      console.error(&#x27;Error parsing stored keys:&#x27;, error);
      return null;
    }
  }

  /**
   * Register public key with the server
   */
  private async registerPublicKey(publicKey: string): Promise&lt;void&gt; {
    try {
      await this.http.post(&#x60;${this.apiUrl}/register-key&#x60;, { publicKey }).toPromise();
    } catch (error) {
      console.error(&#x27;Error registering public key:&#x27;, error);
      throw error;
    }
  }

  /**
   * Setup encryption for a chat room
   * This method handles both creating new room encryption and joining existing encrypted rooms
   */
  setupRoomEncryption(roomId: string): Observable&lt;boolean&gt; {
    if (!this.isEncryptionAvailable()) {
      console.warn(&#x27;Encryption is not available, skipping room encryption setup&#x27;);
      return of(false);
    }

    if (!this.keyPair) {
      console.error(&#x27;Key pair not available for room encryption setup&#x27;);
      return of(false);
    }

    // First check if we already have a key for this room
    if (this.roomKeys.has(roomId)) {
      console.log(&#x60;Room key already exists for room ${roomId}&#x60;);
      return of(true);
    }

    // Export our public key for the server
    return from(this.exportKeyPair(this.keyPair)).pipe(
      switchMap(keys &#x3D;&gt;
        this.http.post&lt;{
          success: boolean;
          encryptedKey?: string;
          isNewSetup?: boolean;
          roomKeyId?: string;
        }&gt;(&#x60;${this.apiUrl}/setup-room&#x60;, {
          roomId,
          publicKey: keys.publicKey,
        })
      ),
      switchMap(async response &#x3D;&gt; {
        if (!response.success) {
          console.error(&#x27;Server reported failure in room encryption setup&#x27;);
          return false;
        }

        try {
          if (response.isNewSetup) {
            // We&#x27;re the first to set up encryption for this room
            // Generate a symmetric key for the room
            const symmetricKey &#x3D; await this.generateSymmetricKey();

            // Export the key to raw format for sending to server
            const exportedKey &#x3D; await window.crypto.subtle.exportKey(&#x27;raw&#x27;, symmetricKey);
            const keyBase64 &#x3D; this.arrayBufferToBase64(exportedKey);

            // Send the symmetric key to the server (encrypted for each participant)
            await this.http
              .post(&#x60;${this.apiUrl}/room-key/${roomId}&#x60;, {
                symmetricKey: keyBase64,
                keyId: response.roomKeyId,
              })
              .toPromise();

            // Store the key in memory
            this.roomKeys.set(roomId, symmetricKey);

            // Also store in localStorage for persistence
            this.storeRoomKey(roomId, keyBase64);

            console.log(&#x60;Created new encryption for room ${roomId}&#x60;);
            return true;
          } else if (response.encryptedKey) {
            // We&#x27;re joining an existing encrypted room
            // Decrypt the room key with our private key
            const encryptedKeyBuffer &#x3D; this.base64ToArrayBuffer(response.encryptedKey);

            if (!this.keyPair.privateKey) {
              console.error(&#x27;Private key not available for decryption&#x27;);
              return false;
            }

            try {
              const decryptedKeyBuffer &#x3D; await window.crypto.subtle.decrypt(
                { name: KEY_PAIR_ALGORITHM },
                this.keyPair.privateKey,
                encryptedKeyBuffer
              );

              // Import the symmetric key
              const symmetricKey &#x3D; await window.crypto.subtle.importKey(
                &#x27;raw&#x27;,
                decryptedKeyBuffer,
                { name: SYMMETRIC_ALGORITHM, length: 256 },
                true,
                [&#x27;encrypt&#x27;, &#x27;decrypt&#x27;]
              );

              // Store the key in memory
              this.roomKeys.set(roomId, symmetricKey);

              // Also store in localStorage for persistence
              this.storeRoomKey(roomId, this.arrayBufferToBase64(decryptedKeyBuffer));

              console.log(&#x60;Joined existing encrypted room ${roomId}&#x60;);
              return true;
            } catch (decryptError) {
              console.error(&#x27;Error decrypting room key:&#x27;, decryptError);
              return false;
            }
          } else {
            console.error(&#x27;No encrypted key provided for existing room&#x27;);
            return false;
          }
        } catch (error) {
          console.error(&#x27;Error setting up room encryption:&#x27;, error);
          return false;
        }
      }),
      catchError(error &#x3D;&gt; {
        console.error(&#x27;Error in room encryption setup process:&#x27;, error);
        return of(false);
      })
    );
  }

  /**
   * Store a room key in localStorage for persistence
   */
  private storeRoomKey(roomId: string, keyBase64: string): void {
    const userId &#x3D; this.authService.getCurrentUserId();
    if (!userId) {
      console.error(&#x27;User ID not available for storing room key&#x27;);
      return;
    }

    try {
      // Get existing room keys or initialize empty object
      const roomKeysKey &#x3D; &#x60;${KEY_STORAGE_PREFIX}${userId}_rooms&#x60;;
      const existingKeys &#x3D; localStorage.getItem(roomKeysKey);
      const roomKeysMap &#x3D; existingKeys ? JSON.parse(existingKeys) : {};

      // Add or update this room&#x27;s key
      roomKeysMap[roomId] &#x3D; keyBase64;

      // Store back to localStorage
      localStorage.setItem(roomKeysKey, JSON.stringify(roomKeysMap));
    } catch (error) {
      console.error(&#x27;Error storing room key:&#x27;, error);
    }
  }

  /**
   * Generate a symmetric key for a chat room
   */
  private async generateSymmetricKey(): Promise&lt;CryptoKey&gt; {
    return window.crypto.subtle.generateKey(
      {
        name: SYMMETRIC_ALGORITHM,
        length: 256,
      },
      true, // extractable
      [&#x27;encrypt&#x27;, &#x27;decrypt&#x27;]
    );
  }

  /**
   * Get the room key for a specific room
   * This method tries multiple sources to get the key:
   * 1. In-memory cache
   * 2. Local storage
   * 3. Server (which will encrypt it with our public key)
   */
  async getRoomKey(roomId: string): Promise&lt;CryptoKey | null&gt; {
    // Check if we already have the key in memory
    if (this.roomKeys.has(roomId)) {
      return this.roomKeys.get(roomId)!;
    }

    try {
      // Try to get the key from localStorage
      const storedKey &#x3D; this.getStoredRoomKey(roomId);
      if (storedKey) {
        try {
          // Import the symmetric key from the stored raw format
          const symmetricKey &#x3D; await window.crypto.subtle.importKey(
            &#x27;raw&#x27;,
            this.base64ToArrayBuffer(storedKey),
            {
              name: SYMMETRIC_ALGORITHM,
              length: 256,
            },
            true,
            [&#x27;encrypt&#x27;, &#x27;decrypt&#x27;]
          );

          // Store in memory for future use
          this.roomKeys.set(roomId, symmetricKey);
          console.log(&#x60;Loaded room key for ${roomId} from local storage&#x60;);
          return symmetricKey;
        } catch (importError) {
          console.error(&#x27;Error importing stored room key:&#x27;, importError);
          // Continue to try getting from server
        }
      }

      // If not in localStorage, get from server
      console.log(&#x60;Requesting room key for ${roomId} from server&#x60;);
      const response &#x3D; await this.http
        .get&lt;{ encryptedKey: string; success: boolean }&gt;(&#x60;${this.apiUrl}/room-key/${roomId}&#x60;)
        .toPromise();

      if (!response || !response.success || !response.encryptedKey) {
        console.error(&#x27;Failed to get room key from server&#x27;);
        return null;
      }

      // Decrypt the room key with our private key
      const encryptedKeyBuffer &#x3D; this.base64ToArrayBuffer(response.encryptedKey);

      if (!this.keyPair || !this.keyPair.privateKey) {
        console.error(&#x27;Private key not available for room key decryption&#x27;);
        return null;
      }

      const decryptedKeyBuffer &#x3D; await window.crypto.subtle.decrypt(
        {
          name: KEY_PAIR_ALGORITHM,
        },
        this.keyPair.privateKey,
        encryptedKeyBuffer
      );

      // Import the symmetric key
      const symmetricKey &#x3D; await window.crypto.subtle.importKey(
        &#x27;raw&#x27;,
        decryptedKeyBuffer,
        {
          name: SYMMETRIC_ALGORITHM,
          length: 256,
        },
        true,
        [&#x27;encrypt&#x27;, &#x27;decrypt&#x27;]
      );

      // Store the key in memory
      this.roomKeys.set(roomId, symmetricKey);

      // Also store in localStorage for persistence
      this.storeRoomKey(roomId, this.arrayBufferToBase64(decryptedKeyBuffer));

      console.log(&#x60;Retrieved and stored room key for ${roomId} from server&#x60;);
      return symmetricKey;
    } catch (error) {
      console.error(&#x27;Error getting room key:&#x27;, error);
      return null;
    }
  }

  /**
   * Get a stored room key from localStorage
   */
  private getStoredRoomKey(roomId: string): string | null {
    const userId &#x3D; this.authService.getCurrentUserId();
    if (!userId) {
      return null;
    }

    try {
      const roomKeysKey &#x3D; &#x60;${KEY_STORAGE_PREFIX}${userId}_rooms&#x60;;
      const storedKeys &#x3D; localStorage.getItem(roomKeysKey);
      if (!storedKeys) {
        return null;
      }

      const roomKeysMap &#x3D; JSON.parse(storedKeys);
      return roomKeysMap[roomId] || null;
    } catch (error) {
      console.error(&#x27;Error retrieving stored room key:&#x27;, error);
      return null;
    }
  }

  /**
   * Encrypt a message for a specific room
   */
  /**
   * Set message expiry settings for a specific room
   * @param roomId The room ID
   * @param settings The expiry settings to apply
   */
  setMessageExpirySettings(roomId: string, settings: MessageExpirySettings): void {
    this.messageExpirySettings.set(roomId, settings);

    // Store settings in localStorage for persistence
    this.storeExpirySettings(roomId, settings);
  }

  /**
   * Get message expiry settings for a specific room
   * @param roomId The room ID
   * @returns The expiry settings for the room, or the default settings if none are set
   */
  getMessageExpirySettings(roomId: string): MessageExpirySettings {
    // Check if we have room-specific settings
    if (this.messageExpirySettings.has(roomId)) {
      return this.messageExpirySettings.get(roomId)!;
    }

    // Try to load from localStorage
    const storedSettings &#x3D; this.getStoredExpirySettings(roomId);
    if (storedSettings) {
      this.messageExpirySettings.set(roomId, storedSettings);
      return storedSettings;
    }

    // Fall back to default settings
    return this.defaultExpirySettings;
  }

  /**
   * Store message expiry settings in localStorage
   * @param roomId The room ID
   * @param settings The settings to store
   */
  private storeExpirySettings(roomId: string, settings: MessageExpirySettings): void {
    const userId &#x3D; this.authService.getCurrentUserId();
    if (!userId) return;

    try {
      const key &#x3D; &#x60;${KEY_STORAGE_PREFIX}${userId}_expiry_settings&#x60;;
      const existingSettings &#x3D; localStorage.getItem(key);
      const settingsMap &#x3D; existingSettings ? JSON.parse(existingSettings) : {};

      settingsMap[roomId] &#x3D; settings;
      localStorage.setItem(key, JSON.stringify(settingsMap));
    } catch (error) {
      console.error(&#x27;Error storing message expiry settings:&#x27;, error);
    }
  }

  /**
   * Get stored message expiry settings from localStorage
   * @param roomId The room ID
   * @returns The stored settings, or null if none exist
   */
  private getStoredExpirySettings(roomId: string): MessageExpirySettings | null {
    const userId &#x3D; this.authService.getCurrentUserId();
    if (!userId) return null;

    try {
      const key &#x3D; &#x60;${KEY_STORAGE_PREFIX}${userId}_expiry_settings&#x60;;
      const storedSettings &#x3D; localStorage.getItem(key);
      if (!storedSettings) return null;

      const settingsMap &#x3D; JSON.parse(storedSettings);
      return settingsMap[roomId] || null;
    } catch (error) {
      console.error(&#x27;Error retrieving stored message expiry settings:&#x27;, error);
      return null;
    }
  }

  /**
   * Calculate the expiry timestamp for a message
   * @param roomId The room ID
   * @returns The timestamp when the message should expire, or undefined if auto-deletion is disabled
   */
  private calculateMessageExpiry(roomId: string): number | undefined {
    const settings &#x3D; this.getMessageExpirySettings(roomId);

    if (!settings.enabled) {
      return undefined;
    }

    return Date.now() + settings.ttl;
  }

  async encryptMessage(
    roomId: string,
    message: string,
    ttl?: number
  ): Promise&lt;EncryptedData | null&gt; {
    if (!this.isEncryptionAvailable()) {
      return null;
    }

    try {
      const roomKey &#x3D; await this.getRoomKey(roomId);
      if (!roomKey) {
        console.error(&#x27;Room key not available for encryption&#x27;);
        return null;
      }

      // Generate a random IV
      const iv &#x3D; window.crypto.getRandomValues(new Uint8Array(12));

      // Encrypt the message
      const encodedMessage &#x3D; new TextEncoder().encode(message);
      const encryptedBuffer &#x3D; await window.crypto.subtle.encrypt(
        {
          name: SYMMETRIC_ALGORITHM,
          iv,
          tagLength: 128,
        },
        roomKey,
        encodedMessage
      );

      // Extract ciphertext and auth tag
      const encryptedBytes &#x3D; new Uint8Array(encryptedBuffer);
      const ciphertextLength &#x3D; encryptedBytes.length - 16; // 16 bytes for auth tag
      const ciphertext &#x3D; encryptedBytes.slice(0, ciphertextLength);
      const authTag &#x3D; encryptedBytes.slice(ciphertextLength);

      // Calculate message expiry timestamp
      // If a specific TTL is provided, use it; otherwise, use the default expiry calculation
      const expiresAt &#x3D; ttl ? Date.now() + ttl : this.calculateMessageExpiry(roomId);

      return {
        ciphertext: this.arrayBufferToBase64(ciphertext),
        iv: this.arrayBufferToBase64(iv),
        authTag: this.arrayBufferToBase64(authTag),
        expiresAt,
      };
    } catch (error) {
      console.error(&#x27;Error encrypting message:&#x27;, error);
      return null;
    }
  }

  /**
   * Decrypt a message from a specific room
   */
  async decryptMessage(roomId: string, encryptedData: EncryptedData): Promise&lt;string | null&gt; {
    if (!this.isEncryptionAvailable()) {
      return null;
    }

    try {
      const roomKey &#x3D; await this.getRoomKey(roomId);
      if (!roomKey) {
        console.error(&#x27;Room key not available for decryption&#x27;);
        return null;
      }

      // Convert base64 to array buffers
      const ciphertext &#x3D; this.base64ToArrayBuffer(encryptedData.ciphertext);
      const iv &#x3D; this.base64ToArrayBuffer(encryptedData.iv);
      const authTag &#x3D; encryptedData.authTag
        ? this.base64ToArrayBuffer(encryptedData.authTag)
        : new Uint8Array(0);

      // Combine ciphertext and auth tag
      const encryptedBuffer &#x3D; new Uint8Array(ciphertext.byteLength + authTag.byteLength);
      encryptedBuffer.set(new Uint8Array(ciphertext), 0);
      encryptedBuffer.set(new Uint8Array(authTag), ciphertext.byteLength);

      // Decrypt the message
      const decryptedBuffer &#x3D; await window.crypto.subtle.decrypt(
        {
          name: SYMMETRIC_ALGORITHM,
          iv,
          tagLength: 128,
        },
        roomKey,
        encryptedBuffer
      );

      // Decode the decrypted message
      return new TextDecoder().decode(decryptedBuffer);
    } catch (error) {
      console.error(&#x27;Error decrypting message:&#x27;, error);
      return null;
    }
  }

  /**
   * Convert an ArrayBuffer to a Base64 string
   */
  private arrayBufferToBase64(buffer: ArrayBuffer | Uint8Array): string {
    const bytes &#x3D; new Uint8Array(buffer);
    let binary &#x3D; &#x27;&#x27;;
    for (let i &#x3D; 0; i &lt; bytes.byteLength; i++) {
      binary +&#x3D; String.fromCharCode(bytes[i]);
    }
    return btoa(binary);
  }

  /**
   * Rotate the encryption key for a room
   * This enhances security by periodically changing the encryption key
   * @param roomId The ID of the room to rotate keys for
   * @returns Observable&lt;boolean&gt; Success status
   */
  rotateRoomKey(roomId: string): Observable&lt;boolean&gt; {
    if (!this.isEncryptionAvailable() || !this.keyPair) {
      console.warn(&#x27;Encryption not available for key rotation&#x27;);
      return of(false);
    }

    return from(this.exportKeyPair(this.keyPair)).pipe(
      switchMap(keys &#x3D;&gt;
        this.http.post&lt;{
          success: boolean;
          roomKeyId?: string;
        }&gt;(&#x60;${this.apiUrl}/rotate-key/${roomId}&#x60;, {
          publicKey: keys.publicKey,
        })
      ),
      switchMap(async response &#x3D;&gt; {
        if (!response.success) {
          console.error(&#x27;Server reported failure in key rotation&#x27;);
          return false;
        }

        try {
          // Generate a new symmetric key for the room
          const newSymmetricKey &#x3D; await this.generateSymmetricKey();

          // Export the key to raw format for sending to server
          const exportedKey &#x3D; await window.crypto.subtle.exportKey(&#x27;raw&#x27;, newSymmetricKey);
          const keyBase64 &#x3D; this.arrayBufferToBase64(exportedKey);

          // Send the new symmetric key to the server
          await this.http
            .post(&#x60;${this.apiUrl}/room-key/${roomId}&#x60;, {
              symmetricKey: keyBase64,
              keyId: response.roomKeyId,
              isRotation: true,
            })
            .toPromise();

          // Update the key in memory
          this.roomKeys.set(roomId, newSymmetricKey);

          // Update in localStorage
          this.storeRoomKey(roomId, keyBase64);

          console.log(&#x60;Successfully rotated encryption key for room ${roomId}&#x60;);
          return true;
        } catch (error) {
          console.error(&#x27;Error rotating room key:&#x27;, error);
          return false;
        }
      }),
      catchError(error &#x3D;&gt; {
        console.error(&#x27;Error in key rotation process:&#x27;, error);
        return of(false);
      })
    );
  }

  /**
   * Schedule automatic key rotation for a room
   * @param roomId The ID of the room to schedule key rotation for
   * @param intervalDays Number of days between rotations (default: 30)
   */
  scheduleKeyRotation(roomId: string, intervalDays &#x3D; 30): void {
    if (!this.isEncryptionAvailable()) {
      return;
    }

    const userId &#x3D; this.authService.getCurrentUserId();
    if (!userId) {
      return;
    }

    try {
      // Store the last rotation time and interval
      const rotationKey &#x3D; &#x60;${KEY_STORAGE_PREFIX}${userId}_rotation&#x60;;
      const rotationData &#x3D; localStorage.getItem(rotationKey);
      const rotations &#x3D; rotationData ? JSON.parse(rotationData) : {};

      // Set the last rotation time to now
      rotations[roomId] &#x3D; {
        lastRotation: Date.now(),
        intervalDays: intervalDays,
      };

      localStorage.setItem(rotationKey, JSON.stringify(rotations));

      console.log(&#x60;Scheduled key rotation for room ${roomId} every ${intervalDays} days&#x60;);
    } catch (error) {
      console.error(&#x27;Error scheduling key rotation:&#x27;, error);
    }
  }

  /**
   * Check if any room keys need rotation and perform rotation if needed
   * This should be called periodically, e.g., when the app starts
   */
  checkAndPerformKeyRotations(): void {
    if (!this.isEncryptionAvailable()) {
      return;
    }

    const userId &#x3D; this.authService.getCurrentUserId();
    if (!userId) {
      return;
    }

    try {
      const rotationKey &#x3D; &#x60;${KEY_STORAGE_PREFIX}${userId}_rotation&#x60;;
      const rotationData &#x3D; localStorage.getItem(rotationKey);
      if (!rotationData) {
        return;
      }

      const rotations &#x3D; JSON.parse(rotationData);
      const now &#x3D; Date.now();

      Object.entries(rotations).forEach(([roomId, data]: [string, any]) &#x3D;&gt; {
        const { lastRotation, intervalDays } &#x3D; data;
        const rotationInterval &#x3D; intervalDays * 24 * 60 * 60 * 1000; // Convert days to ms

        if (now - lastRotation &gt;&#x3D; rotationInterval) {
          console.log(&#x60;Key rotation needed for room ${roomId}&#x60;);

          // Perform key rotation
          this.rotateRoomKey(roomId).subscribe(success &#x3D;&gt; {
            if (success) {
              // Update last rotation time
              rotations[roomId].lastRotation &#x3D; now;
              localStorage.setItem(rotationKey, JSON.stringify(rotations));
            }
          });
        }
      });
    } catch (error) {
      console.error(&#x27;Error checking for key rotations:&#x27;, error);
    }
  }

  /**
   * Convert a Base64 string to an ArrayBuffer
   */
  private base64ToArrayBuffer(base64: string): ArrayBuffer {
    const binaryString &#x3D; atob(base64);
    const bytes &#x3D; new Uint8Array(binaryString.length);
    for (let i &#x3D; 0; i &lt; binaryString.length; i++) {
      bytes[i] &#x3D; binaryString.charCodeAt(i);
    }
    return bytes.buffer;
  }
}
</code></pre>
    </div>
</div>








                   </div><div class="search-results">
    <div class="has-results">
        <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
        <ul class="search-results-list"></ul>
    </div>
    <div class="no-results">
        <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
    </div>
</div>
</div>
               <!-- END CONTENT -->
           </div>
       </div>

          <label class="dark-mode-switch">
               <input type="checkbox">
               <span class="slider">
                    <svg class="slider-icon" viewBox="0 0 24 24" fill="none" height="20" stroke="#000" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" width="20" xmlns="http://www.w3.org/2000/svg">
                    <path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"></path>
                    </svg>
               </span>
          </label>

       <script>
            var COMPODOC_CURRENT_PAGE_DEPTH = 1;
            var COMPODOC_CURRENT_PAGE_CONTEXT = 'interface';
            var COMPODOC_CURRENT_PAGE_URL = 'EncryptionKeys.html';
            var MAX_SEARCH_RESULTS = 15;
       </script>

       <script>
               $darkModeToggleSwitchers = document.querySelectorAll('.dark-mode-switch input');
               checkToggle(darkModeState);
               if ($darkModeToggleSwitchers.length > 0) {
                    for (var i = 0; i < $darkModeToggleSwitchers.length; i++) {
                         $darkModeToggleSwitchers[i].addEventListener('change', function (event) {
                              darkModeState = !darkModeState;
                              toggleDarkMode(darkModeState);
                         });
                    }
               }
          </script>

       <script src="../js/libs/custom-elements.min.js"></script>
       <script src="../js/libs/lit-html.js"></script>

       <script src="../js/menu-wc.js" defer></script>
       <script nomodule src="../js/menu-wc_es5.js" defer></script>

       <script src="../js/libs/bootstrap-native.js"></script>

       <script src="../js/libs/es6-shim.min.js"></script>
       <script src="../js/libs/EventDispatcher.js"></script>
       <script src="../js/libs/promise.min.js"></script>

       <script src="../js/compodoc.js"></script>

       <script src="../js/tabs.js"></script>
       <script src="../js/menu.js"></script>
       <script src="../js/libs/clipboard.min.js"></script>
       <script src="../js/libs/prism.js"></script>
       <script src="../js/sourceCode.js"></script>
          <script src="../js/search/search.js"></script>
          <script src="../js/search/lunr.min.js"></script>
          <script src="../js/search/search-lunr.js"></script>
          <script src="../js/search/search_index.js"></script>
       <script src="../js/lazy-load-graphs.js"></script>


    </body>
</html>
