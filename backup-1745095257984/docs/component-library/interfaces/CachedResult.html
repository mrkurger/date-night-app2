<!doctype html>
<html class="no-js" lang="">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <title>client-angular documentation</title>
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <link rel="icon" type="image/x-icon" href="../images/favicon.ico">
	   <link rel="stylesheet" href="../styles/style.css">
        <link rel="stylesheet" href="../styles/dark.css">
    </head>
    <body>
          <script>
               // Blocking script to avoid flickering dark mode
               // Dark mode toggle button
               var useDark = window.matchMedia('(prefers-color-scheme: dark)');
               var darkModeState = useDark.matches;
               var $darkModeToggleSwitchers = document.querySelectorAll('.dark-mode-switch input');
               var $darkModeToggles = document.querySelectorAll('.dark-mode-switch');
               var darkModeStateLocal = localStorage.getItem('compodoc_darkmode-state');

               function checkToggle(check) {
                    for (var i = 0; i < $darkModeToggleSwitchers.length; i++) {
                         $darkModeToggleSwitchers[i].checked = check;
                    }
               }

               function toggleDarkMode(state) {
                    if (window.localStorage) {
                         localStorage.setItem('compodoc_darkmode-state', state);
                    }

                    checkToggle(state);

                    const hasClass = document.body.classList.contains('dark');

                    if (state) {
                         for (var i = 0; i < $darkModeToggles.length; i++) {
                              $darkModeToggles[i].classList.add('dark');
                         }
                         if (!hasClass) {
                              document.body.classList.add('dark');
                         }
                    } else {
                         for (var i = 0; i < $darkModeToggles.length; i++) {
                              $darkModeToggles[i].classList.remove('dark');
                         }
                         if (hasClass) {
                              document.body.classList.remove('dark');
                         }
                    }
               }

               useDark.addEventListener('change', function (evt) {
                    toggleDarkMode(evt.matches);
               });
               if (darkModeStateLocal) {
                    darkModeState = darkModeStateLocal === 'true';
               }
               toggleDarkMode(darkModeState);
          </script>

        <div class="navbar navbar-default navbar-fixed-top d-md-none p-0">
               <div class="d-flex">
                    <a href="../" class="navbar-brand">client-angular documentation</a>
                    <button type="button" class="btn btn-default btn-menu ion-ios-menu" id="btn-menu"></button>
               </div>
        </div>

        <div class="xs-menu menu" id="mobile-menu">
                <div id="book-search-input" role="search"><input type="text" placeholder="Type to search"></div>            <compodoc-menu></compodoc-menu>
        </div>

        <div class="container-fluid main">
           <div class="row main">
               <div class="d-none d-md-block menu">
                   <compodoc-menu mode="normal"></compodoc-menu>
               </div>
               <!-- START CONTENT -->
               <div class="content interface">
                   <div class="content-data">













<ol class="breadcrumb">
  <li class="breadcrumb-item">Interfaces</li>
  <li class="breadcrumb-item"
  >
  CachedResult</li>
</ol>

<ul class="nav nav-tabs" role="tablist">
        <li class="nav-item">
            <a href="#info" 
                class="nav-link"
                class="nav-link active"
                role="tab" id="info-tab" data-bs-toggle="tab" data-link="info">Info</a>
        </li>
        <li class="nav-item">
            <a href="#source" 
                class="nav-link"
                
                role="tab" id="source-tab" data-bs-toggle="tab" data-link="source">Source</a>
        </li>
</ul>

<div class="tab-content">
    <div class="tab-pane fade active in" id="info">
        <p class="comment">
            <h3>File</h3>
        </p>
        <p class="comment">
            <code>src/app/core/services/geocoding.service.ts</code>
        </p>




        <section data-compodoc="block-index">
            <h3 id="index">Index</h3>
            <table class="table table-sm table-bordered index-table">
                <tbody>
                    <tr>
                        <td class="col-md-4">
                            <h6><b>Properties</b></h6>
                        </td>
                    </tr>
                    <tr>
                        <td class="col-md-4">
                            <ul class="index-list">
                                <li>
                                        <a href="#result" 
>
                                            result
                                        </a>
                                </li>
                                <li>
                                        <a href="#timestamp" 
>
                                            timestamp
                                        </a>
                                </li>
                            </ul>
                        </td>
                    </tr>
                </tbody>
            </table>
        </section>



            <section data-compodoc="block-properties">
                <h3 id="inputs">Properties</h3>
                    <table class="table table-sm table-bordered">
                        <tbody>
                                <tr>
                                    <td class="col-md-4">
                                        <a name="result"></a>
                                        <span class="name "><b>result</b>
                                            <a href="#result">
                                                <span class="icon ion-ios-link"></span>
                                            </a>
                                        </span>
                                    </td>
                                </tr>
                                <tr>
                                    <td class="col-md-4">
                                        <code>result:         <code><a href="https://www.typescriptlang.org/docs/handbook/basic-types.html" target="_blank" >any</a></code>
</code>
                                    </td>
                                </tr>


                                    <tr>
                                        <td class="col-md-4">
                                            <i>Type : </i>        <code><a href="https://www.typescriptlang.org/docs/handbook/basic-types.html" target="_blank" >any</a></code>

                                        </td>
                                    </tr>





                        </tbody>
                    </table>
                    <table class="table table-sm table-bordered">
                        <tbody>
                                <tr>
                                    <td class="col-md-4">
                                        <a name="timestamp"></a>
                                        <span class="name "><b>timestamp</b>
                                            <a href="#timestamp">
                                                <span class="icon ion-ios-link"></span>
                                            </a>
                                        </span>
                                    </td>
                                </tr>
                                <tr>
                                    <td class="col-md-4">
                                        <code>timestamp:         <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/number" target="_blank" >number</a></code>
</code>
                                    </td>
                                </tr>


                                    <tr>
                                        <td class="col-md-4">
                                            <i>Type : </i>        <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/number" target="_blank" >number</a></code>

                                        </td>
                                    </tr>





                        </tbody>
                    </table>
            </section>
    </div>


    <div class="tab-pane fade  tab-source-code" id="source">
        <pre class="line-numbers compodoc-sourcecode"><code class="language-typescript">import { Injectable } from &#x27;@angular/core&#x27;;
import { HttpClient } from &#x27;@angular/common/http&#x27;;
import { Observable, of } from &#x27;rxjs&#x27;;
import { catchError, map, tap } from &#x27;rxjs/operators&#x27;;
import { environment } from &#x27;../../../environments/environment&#x27;;
import { LocationService } from &#x27;./location.service&#x27;;

// Constants
const API_PROVIDER &#x3D; &#x27;nominatim&#x27;; // &#x27;nominatim&#x27;, &#x27;mapbox&#x27;, or &#x27;google&#x27;
const MAPBOX_ACCESS_TOKEN &#x3D; environment.mapboxToken || &#x27;&#x27;;
const GOOGLE_MAPS_API_KEY &#x3D; environment.googleMapsApiKey || &#x27;&#x27;;
const CACHE_DURATION &#x3D; 24 * 60 * 60 * 1000; // 24 hours in milliseconds

export interface GeocodingResult {
  type: &#x27;Point&#x27;;
  coordinates: [number, number]; // [longitude, latitude]
}

export interface EnhancedGeocodingResult {
  id?: string;
  name: string;
  formattedAddress: string;
  latitude: number;
  longitude: number;
  country?: string;
  countryCode?: string;
  city?: string;
  state?: string;
  postalCode?: string;
  neighborhood?: string;
  provider: string;
  timestamp: number;
}

export interface ReverseGeocodingResult {
  formattedAddress: string;
  latitude: number;
  longitude: number;
  components: {
    country?: string;
    countryCode?: string;
    city?: string;
    state?: string;
    postalCode?: string;
    neighborhood?: string;
    street?: string;
    streetNumber?: string;
  };
  provider: string;
  timestamp: number;
}

interface CachedResult {
  result: any;
  timestamp: number;
}

/**
 * Service for geocoding addresses and locations
 * Provides methods for converting addresses to coordinates and vice versa
 */
@Injectable({
  providedIn: &#x27;root&#x27;,
})
export class GeocodingService {
  private readonly apiUrl &#x3D; environment.apiUrl + &#x27;/geocoding&#x27;;

  // API key would typically be stored in environment variables
  private readonly nominatimUrl &#x3D; &#x27;https://nominatim.openstreetmap.org/search&#x27;;
  private readonly reverseNominatimUrl &#x3D; &#x27;https://nominatim.openstreetmap.org/reverse&#x27;;

  // Cache for geocoding results
  private cache: Map&lt;string, CachedResult&gt; &#x3D; new Map();

  constructor(
    private http: HttpClient,
    private locationService: LocationService
  ) {}

  /**
   * Geocode an address to get coordinates
   * @param address The address to geocode
   * @returns Observable with coordinates [longitude, latitude]
   */
  geocodeAddress(address: string): Observable&lt;GeocodingResult | null&gt; {
    // First try the backend API
    return this.http
      .get&lt;GeocodingResult&gt;(&#x60;${this.apiUrl}/forward?address&#x3D;${encodeURIComponent(address)}&#x60;)
      .pipe(
        catchError(() &#x3D;&gt;
          // If backend fails, try Nominatim directly
          this.geocodeWithNominatim(address)
        )
      );
  }

  /**
   * Geocode a location by city, county, and country
   * @param city City name
   * @param county County name
   * @param country Country name (default: Norway)
   * @returns Observable with coordinates [longitude, latitude]
   */
  geocodeLocation(
    city: string,
    county: string,
    country &#x3D; &#x27;Norway&#x27;
  ): Observable&lt;GeocodingResult | null&gt; {
    // First check if we have the coordinates in our local database
    return this.locationService.getCityCoordinates(city).pipe(
      map(coordinates &#x3D;&gt; {
        if (coordinates) {
          return {
            type: &#x27;Point&#x27;,
            coordinates,
          };
        }
        return null;
      }),
      catchError(() &#x3D;&gt; of(null)),
      // If not found locally, try the backend API
      catchError(() &#x3D;&gt; {
        const address &#x3D; &#x60;${city}, ${county}, ${country}&#x60;;
        return this.http
          .get&lt;GeocodingResult&gt;(
            &#x60;${this.apiUrl}/forward?city&#x3D;${encodeURIComponent(city)}&amp;county&#x3D;${encodeURIComponent(
              county
            )}&amp;country&#x3D;${encodeURIComponent(country)}&#x60;
          )
          .pipe(
            catchError(() &#x3D;&gt;
              // If backend fails, try Nominatim directly
              this.geocodeWithNominatim(address)
            )
          );
      })
    );
  }

  /**
   * Reverse geocode coordinates to get an address
   * @param longitude Longitude
   * @param latitude Latitude
   * @returns Observable with address information
   */
  reverseGeocode(
    longitude: number,
    latitude: number
  ): Observable&lt;{
    city: string;
    county: string;
    country: string;
    address: string;
  } | null&gt; {
    // First try the backend API
    return this.http
      .get&lt;{
        city: string;
        county: string;
        country: string;
        address: string;
      }&gt;(&#x60;${this.apiUrl}/reverse?longitude&#x3D;${longitude}&amp;latitude&#x3D;${latitude}&#x60;)
      .pipe(
        catchError(() &#x3D;&gt;
          // If backend fails, try to find the nearest city from our local database
          this.locationService.findNearestCity(latitude, longitude).pipe(
            map(result &#x3D;&gt; {
              if (result) {
                return {
                  city: result.city,
                  county: result.county,
                  country: &#x27;Norway&#x27;,
                  address: &#x60;${result.city}, ${result.county}, Norway&#x60;,
                };
              }
              return null;
            }),
            catchError(() &#x3D;&gt;
              // If local database fails, try Nominatim directly
              this.reverseGeocodeWithNominatim(longitude, latitude)
            )
          )
        )
      );
  }

  /**
   * Geocode an address using Nominatim directly
   * @param address The address to geocode
   * @returns Observable with coordinates [longitude, latitude]
   */
  private geocodeWithNominatim(address: string): Observable&lt;GeocodingResult | null&gt; {
    const params &#x3D; {
      q: address,
      format: &#x27;json&#x27;,
      limit: &#x27;1&#x27;,
    };

    const queryString &#x3D; Object.entries(params)
      .map(([key, value]) &#x3D;&gt; &#x60;${key}&#x3D;${encodeURIComponent(value)}&#x60;)
      .join(&#x27;&amp;&#x27;);

    return this.http.get&lt;any[]&gt;(&#x60;${this.nominatimUrl}?${queryString}&#x60;).pipe(
      map(response &#x3D;&gt; {
        if (response &amp;&amp; response.length &gt; 0) {
          const result &#x3D; response[0];
          return {
            type: &#x27;Point&#x27;,
            coordinates: [parseFloat(result.lon), parseFloat(result.lat)],
          };
        }
        return null;
      }),
      catchError(() &#x3D;&gt; of(null))
    );
  }

  /**
   * Reverse geocode coordinates using Nominatim directly
   * @param longitude Longitude
   * @param latitude Latitude
   * @returns Observable with address information
   */
  private reverseGeocodeWithNominatim(
    longitude: number,
    latitude: number
  ): Observable&lt;{
    city: string;
    county: string;
    country: string;
    address: string;
  } | null&gt; {
    const params &#x3D; {
      lat: latitude.toString(),
      lon: longitude.toString(),
      format: &#x27;json&#x27;,
      &#x27;accept-language&#x27;: &#x27;en&#x27;,
    };

    const queryString &#x3D; Object.entries(params)
      .map(([key, value]) &#x3D;&gt; &#x60;${key}&#x3D;${encodeURIComponent(value)}&#x60;)
      .join(&#x27;&amp;&#x27;);

    return this.http.get&lt;any&gt;(&#x60;${this.reverseNominatimUrl}?${queryString}&#x60;).pipe(
      map(response &#x3D;&gt; {
        if (response &amp;&amp; response.address) {
          const address &#x3D; response.address;
          return {
            city: address.city || address.town || address.village || address.hamlet || &#x27;&#x27;,
            county: address.county || address.state || &#x27;&#x27;,
            country: address.country || &#x27;&#x27;,
            address: response.display_name || &#x27;&#x27;,
          };
        }
        return null;
      }),
      catchError(() &#x3D;&gt; of(null))
    );
  }

  /**
   * Enhanced geocode method that returns more detailed information
   * @param address The address to geocode
   * @returns An observable with detailed geocoding result
   */
  enhancedGeocode(address: string): Observable&lt;EnhancedGeocodingResult | null&gt; {
    // Check cache first
    const cacheKey &#x3D; &#x60;enhanced:${address}&#x60;;
    const cachedResult &#x3D; this.getFromCache&lt;EnhancedGeocodingResult&gt;(cacheKey);
    if (cachedResult) {
      return of(cachedResult);
    }

    // Choose the appropriate geocoding provider
    switch (API_PROVIDER) {
      case &#x27;nominatim&#x27;:
        return this.enhancedNominatimGeocode(address).pipe(
          tap(result &#x3D;&gt; {
            if (result) {
              this.addToCache(cacheKey, result);
            }
          })
        );
      case &#x27;mapbox&#x27;:
        return this.mapboxGeocode(address).pipe(
          tap(result &#x3D;&gt; {
            if (result) {
              this.addToCache(cacheKey, result);
            }
          })
        );
      case &#x27;google&#x27;:
        return this.googleGeocode(address).pipe(
          tap(result &#x3D;&gt; {
            if (result) {
              this.addToCache(cacheKey, result);
            }
          })
        );
      default:
        throw new Error(&#x60;Unsupported geocoding provider: ${API_PROVIDER}&#x60;);
    }
  }

  /**
   * Enhanced reverse geocode method that returns more detailed information
   * @param latitude The latitude
   * @param longitude The longitude
   * @returns An observable with detailed reverse geocoding result
   */
  enhancedReverseGeocode(
    latitude: number,
    longitude: number
  ): Observable&lt;ReverseGeocodingResult | null&gt; {
    // Check cache first
    const cacheKey &#x3D; &#x60;enhanced-reverse:${latitude},${longitude}&#x60;;
    const cachedResult &#x3D; this.getFromCache&lt;ReverseGeocodingResult&gt;(cacheKey);
    if (cachedResult) {
      return of(cachedResult);
    }

    // Choose the appropriate geocoding provider
    switch (API_PROVIDER) {
      case &#x27;nominatim&#x27;:
        return this.enhancedNominatimReverseGeocode(latitude, longitude).pipe(
          tap(result &#x3D;&gt; {
            if (result) {
              this.addToCache(cacheKey, result);
            }
          })
        );
      case &#x27;mapbox&#x27;:
        return this.mapboxReverseGeocode(latitude, longitude).pipe(
          tap(result &#x3D;&gt; {
            if (result) {
              this.addToCache(cacheKey, result);
            }
          })
        );
      case &#x27;google&#x27;:
        return this.googleReverseGeocode(latitude, longitude).pipe(
          tap(result &#x3D;&gt; {
            if (result) {
              this.addToCache(cacheKey, result);
            }
          })
        );
      default:
        throw new Error(&#x60;Unsupported geocoding provider: ${API_PROVIDER}&#x60;);
    }
  }

  /**
   * Get the distance between two coordinates in kilometers
   * @param lat1 Latitude of the first point
   * @param lon1 Longitude of the first point
   * @param lat2 Latitude of the second point
   * @param lon2 Longitude of the second point
   * @returns The distance in kilometers
   */
  getDistance(lat1: number, lon1: number, lat2: number, lon2: number): number {
    // Haversine formula to calculate distance between two points on Earth
    const R &#x3D; 6371; // Earth&#x27;s radius in km
    const dLat &#x3D; this.toRadians(lat2 - lat1);
    const dLon &#x3D; this.toRadians(lon2 - lon1);
    const a &#x3D;
      Math.sin(dLat / 2) * Math.sin(dLat / 2) +
      Math.cos(this.toRadians(lat1)) *
        Math.cos(this.toRadians(lat2)) *
        Math.sin(dLon / 2) *
        Math.sin(dLon / 2);
    const c &#x3D; 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    const distance &#x3D; R * c;
    return distance;
  }

  /**
   * Get nearby places based on coordinates and radius
   * @param latitude The latitude
   * @param longitude The longitude
   * @param radius The radius in kilometers
   * @param type Optional type of place to search for
   * @returns An observable with the nearby places
   */
  getNearbyPlaces(
    latitude: number,
    longitude: number,
    radius: number,
    type?: string
  ): Observable&lt;EnhancedGeocodingResult[]&gt; {
    // Check cache first
    const cacheKey &#x3D; &#x60;nearby:${latitude},${longitude},${radius},${type || &#x27;&#x27;}&#x60;;
    const cachedResult &#x3D; this.getFromCache&lt;EnhancedGeocodingResult[]&gt;(cacheKey);
    if (cachedResult) {
      return of(cachedResult);
    }

    // Choose the appropriate provider
    switch (API_PROVIDER) {
      case &#x27;nominatim&#x27;:
        return this.nominatimNearbyPlaces(latitude, longitude, radius, type).pipe(
          tap(results &#x3D;&gt; this.addToCache(cacheKey, results))
        );
      case &#x27;mapbox&#x27;:
        return this.mapboxNearbyPlaces(latitude, longitude, radius, type).pipe(
          tap(results &#x3D;&gt; this.addToCache(cacheKey, results))
        );
      case &#x27;google&#x27;:
        return this.googleNearbyPlaces(latitude, longitude, radius, type).pipe(
          tap(results &#x3D;&gt; this.addToCache(cacheKey, results))
        );
      default:
        throw new Error(&#x60;Unsupported provider for nearby places: ${API_PROVIDER}&#x60;);
    }
  }

  /**
   * Get the user&#x27;s current location
   * @returns A promise with the coordinates
   */
  getCurrentLocation(): Promise&lt;{ latitude: number; longitude: number }&gt; {
    return new Promise((resolve, reject) &#x3D;&gt; {
      if (!navigator.geolocation) {
        reject(new Error(&#x27;Geolocation is not supported by your browser&#x27;));
        return;
      }

      navigator.geolocation.getCurrentPosition(
        position &#x3D;&gt; {
          resolve({
            latitude: position.coords.latitude,
            longitude: position.coords.longitude,
          });
        },
        error &#x3D;&gt; {
          reject(error);
        },
        { enableHighAccuracy: true, timeout: 10000, maximumAge: 0 }
      );
    });
  }

  /**
   * Convert degrees to radians
   * @param degrees The angle in degrees
   * @returns The angle in radians
   */
  private toRadians(degrees: number): number {
    return (degrees * Math.PI) / 180;
  }

  /**
   * Add a result to the cache
   * @param key The cache key
   * @param result The result to cache
   */
  private addToCache&lt;T&gt;(key: string, result: T): void {
    this.cache.set(key, {
      result,
      timestamp: Date.now(),
    });
  }

  /**
   * Get a result from the cache if it&#x27;s still valid
   * @param key The cache key
   * @returns The cached result or null if not found or expired
   */
  private getFromCache&lt;T&gt;(key: string): T | null {
    const cached &#x3D; this.cache.get(key);
    if (!cached) {
      return null;
    }

    // Check if the cached result has expired
    if (Date.now() - cached.timestamp &gt; CACHE_DURATION) {
      this.cache.delete(key);
      return null;
    }

    return cached.result as T;
  }

  /**
   * Enhanced geocode using Nominatim
   */
  private enhancedNominatimGeocode(address: string): Observable&lt;EnhancedGeocodingResult | null&gt; {
    const params &#x3D; {
      q: address,
      format: &#x27;json&#x27;,
      limit: &#x27;1&#x27;,
      addressdetails: &#x27;1&#x27;,
    };

    const queryString &#x3D; Object.entries(params)
      .map(([key, value]) &#x3D;&gt; &#x60;${key}&#x3D;${encodeURIComponent(value)}&#x60;)
      .join(&#x27;&amp;&#x27;);

    return this.http.get&lt;any[]&gt;(&#x60;${this.nominatimUrl}?${queryString}&#x60;).pipe(
      map(response &#x3D;&gt; {
        if (response &amp;&amp; response.length &gt; 0) {
          const result &#x3D; response[0];
          const address &#x3D; result.address || {};

          return {
            id: result.place_id,
            name: result.display_name.split(&#x27;,&#x27;)[0] || &#x27;&#x27;,
            formattedAddress: result.display_name,
            latitude: parseFloat(result.lat),
            longitude: parseFloat(result.lon),
            country: address.country,
            countryCode: address.country_code,
            city: address.city || address.town || address.village || address.hamlet,
            state: address.state,
            postalCode: address.postcode,
            neighborhood: address.suburb || address.neighbourhood,
            provider: &#x27;nominatim&#x27;,
            timestamp: Date.now(),
          };
        }
        return null;
      }),
      catchError(error &#x3D;&gt; {
        console.error(&#x27;Error geocoding with Nominatim:&#x27;, error);
        return of(null);
      })
    );
  }

  /**
   * Enhanced reverse geocode using Nominatim
   */
  private enhancedNominatimReverseGeocode(
    latitude: number,
    longitude: number
  ): Observable&lt;ReverseGeocodingResult | null&gt; {
    const params &#x3D; {
      lat: latitude.toString(),
      lon: longitude.toString(),
      format: &#x27;json&#x27;,
      &#x27;accept-language&#x27;: &#x27;en&#x27;,
      addressdetails: &#x27;1&#x27;,
    };

    const queryString &#x3D; Object.entries(params)
      .map(([key, value]) &#x3D;&gt; &#x60;${key}&#x3D;${encodeURIComponent(value)}&#x60;)
      .join(&#x27;&amp;&#x27;);

    return this.http.get&lt;any&gt;(&#x60;${this.reverseNominatimUrl}?${queryString}&#x60;).pipe(
      map(response &#x3D;&gt; {
        if (response &amp;&amp; response.address) {
          const address &#x3D; response.address;

          return {
            formattedAddress: response.display_name,
            latitude,
            longitude,
            components: {
              country: address.country,
              countryCode: address.country_code,
              city: address.city || address.town || address.village || address.hamlet,
              state: address.state,
              postalCode: address.postcode,
              neighborhood: address.suburb || address.neighbourhood,
              street: address.road,
              streetNumber: address.house_number,
            },
            provider: &#x27;nominatim&#x27;,
            timestamp: Date.now(),
          };
        }
        return null;
      }),
      catchError(error &#x3D;&gt; {
        console.error(&#x27;Error reverse geocoding with Nominatim:&#x27;, error);
        return of(null);
      })
    );
  }

  /**
   * Get nearby places using Nominatim
   */
  private nominatimNearbyPlaces(
    latitude: number,
    longitude: number,
    radius: number,
    type?: string
  ): Observable&lt;EnhancedGeocodingResult[]&gt; {
    // Nominatim doesn&#x27;t have a direct &quot;nearby&quot; API, so we&#x27;ll use a bounding box approach
    // Convert radius to a bounding box (approximate)
    const kmInLat &#x3D; 0.009; // ~1km in latitude degrees
    const kmInLon &#x3D; 0.009 / Math.cos(this.toRadians(latitude)); // ~1km in longitude degrees

    const params: any &#x3D; {
      format: &#x27;json&#x27;,
      addressdetails: &#x27;1&#x27;,
      limit: &#x27;50&#x27;,
      viewbox: [
        longitude - kmInLon * radius,
        latitude + kmInLat * radius,
        longitude + kmInLon * radius,
        latitude - kmInLat * radius,
      ].join(&#x27;,&#x27;),
      bounded: &#x27;1&#x27;,
    };

    // Add category/type if provided
    if (type) {
      params.category &#x3D; type;
    }

    const queryString &#x3D; Object.entries(params)
      .map(([key, value]) &#x3D;&gt; &#x60;${key}&#x3D;${encodeURIComponent(value)}&#x60;)
      .join(&#x27;&amp;&#x27;);

    return this.http.get&lt;any[]&gt;(&#x60;${this.nominatimUrl}?${queryString}&#x60;).pipe(
      map(results &#x3D;&gt; {
        if (!results || !Array.isArray(results)) {
          return [];
        }

        return results
          .filter(result &#x3D;&gt; {
            // Filter by actual distance (not just bounding box)
            const resultLat &#x3D; parseFloat(result.lat);
            const resultLon &#x3D; parseFloat(result.lon);
            const distance &#x3D; this.getDistance(latitude, longitude, resultLat, resultLon);
            return distance &lt;&#x3D; radius;
          })
          .map(result &#x3D;&gt; {
            const address &#x3D; result.address || {};

            return {
              id: result.place_id,
              name: result.display_name.split(&#x27;,&#x27;)[0] || &#x27;&#x27;,
              formattedAddress: result.display_name,
              latitude: parseFloat(result.lat),
              longitude: parseFloat(result.lon),
              country: address.country,
              countryCode: address.country_code,
              city: address.city || address.town || address.village || address.hamlet,
              state: address.state,
              postalCode: address.postcode,
              neighborhood: address.suburb || address.neighbourhood,
              provider: &#x27;nominatim&#x27;,
              timestamp: Date.now(),
            };
          });
      }),
      catchError(error &#x3D;&gt; {
        console.error(&#x27;Error getting nearby places with Nominatim:&#x27;, error);
        return of([]);
      })
    );
  }

  /**
   * Geocode an address using Mapbox
   */
  private mapboxGeocode(address: string): Observable&lt;EnhancedGeocodingResult | null&gt; {
    if (!MAPBOX_ACCESS_TOKEN) {
      console.error(&#x27;Mapbox access token not provided&#x27;);
      return of(null);
    }

    const encodedAddress &#x3D; encodeURIComponent(address);
    const url &#x3D; &#x60;https://api.mapbox.com/geocoding/v5/mapbox.places/${encodedAddress}.json?access_token&#x3D;${MAPBOX_ACCESS_TOKEN}&amp;limit&#x3D;1&#x60;;

    return this.http.get&lt;any&gt;(url).pipe(
      map(response &#x3D;&gt; {
        if (!response.features || response.features.length &#x3D;&#x3D;&#x3D; 0) {
          return null;
        }

        const feature &#x3D; response.features[0];
        const [longitude, latitude] &#x3D; feature.center;
        const components &#x3D; this.extractMapboxComponents(feature);

        return {
          id: feature.id,
          name: feature.text || &#x27;&#x27;,
          formattedAddress: feature.place_name || &#x27;&#x27;,
          latitude,
          longitude,
          country: components.country,
          countryCode: components.countryCode,
          city: components.city,
          state: components.state,
          postalCode: components.postalCode,
          neighborhood: components.neighborhood,
          provider: &#x27;mapbox&#x27;,
          timestamp: Date.now(),
        };
      }),
      catchError(error &#x3D;&gt; {
        console.error(&#x27;Error geocoding with Mapbox:&#x27;, error);
        return of(null);
      })
    );
  }

  /**
   * Reverse geocode coordinates using Mapbox
   */
  private mapboxReverseGeocode(
    latitude: number,
    longitude: number
  ): Observable&lt;ReverseGeocodingResult | null&gt; {
    if (!MAPBOX_ACCESS_TOKEN) {
      console.error(&#x27;Mapbox access token not provided&#x27;);
      return of(null);
    }

    const url &#x3D; &#x60;https://api.mapbox.com/geocoding/v5/mapbox.places/${longitude},${latitude}.json?access_token&#x3D;${MAPBOX_ACCESS_TOKEN}&amp;limit&#x3D;1&#x60;;

    return this.http.get&lt;any&gt;(url).pipe(
      map(response &#x3D;&gt; {
        if (!response.features || response.features.length &#x3D;&#x3D;&#x3D; 0) {
          return null;
        }

        const feature &#x3D; response.features[0];
        const components &#x3D; this.extractMapboxComponents(feature);

        return {
          formattedAddress: feature.place_name || &#x27;&#x27;,
          latitude,
          longitude,
          components,
          provider: &#x27;mapbox&#x27;,
          timestamp: Date.now(),
        };
      }),
      catchError(error &#x3D;&gt; {
        console.error(&#x27;Error reverse geocoding with Mapbox:&#x27;, error);
        return of(null);
      })
    );
  }

  /**
   * Get nearby places using Mapbox
   */
  private mapboxNearbyPlaces(
    latitude: number,
    longitude: number,
    radius: number,
    type?: string
  ): Observable&lt;EnhancedGeocodingResult[]&gt; {
    if (!MAPBOX_ACCESS_TOKEN) {
      console.error(&#x27;Mapbox access token not provided&#x27;);
      return of([]);
    }

    // Convert radius from km to meters for the proximity parameter
    const proximityRadius &#x3D; radius * 1000;

    let url &#x3D; &#x60;https://api.mapbox.com/geocoding/v5/mapbox.places/${type || &#x27;&#x27;}.json?proximity&#x3D;${longitude},${latitude}&amp;access_token&#x3D;${MAPBOX_ACCESS_TOKEN}&#x60;;

    // Add type-specific parameters if needed
    if (type) {
      url +&#x3D; &#x60;&amp;types&#x3D;${type}&#x60;;
    }

    return this.http.get&lt;any&gt;(url).pipe(
      map(response &#x3D;&gt; {
        if (!response.features) {
          return [];
        }

        return response.features
          .filter((feature: any) &#x3D;&gt; {
            // Filter results by distance if radius is provided
            if (radius) {
              const [featureLon, featureLat] &#x3D; feature.center;
              const distance &#x3D; this.getDistance(latitude, longitude, featureLat, featureLon);
              return distance &lt;&#x3D; radius;
            }
            return true;
          })
          .map((feature: any) &#x3D;&gt; {
            const [featureLon, featureLat] &#x3D; feature.center;
            const components &#x3D; this.extractMapboxComponents(feature);

            return {
              id: feature.id,
              name: feature.text || &#x27;&#x27;,
              formattedAddress: feature.place_name || &#x27;&#x27;,
              latitude: featureLat,
              longitude: featureLon,
              country: components.country,
              countryCode: components.countryCode,
              city: components.city,
              state: components.state,
              postalCode: components.postalCode,
              neighborhood: components.neighborhood,
              provider: &#x27;mapbox&#x27;,
              timestamp: Date.now(),
            };
          });
      }),
      catchError(error &#x3D;&gt; {
        console.error(&#x27;Error getting nearby places with Mapbox:&#x27;, error);
        return of([]);
      })
    );
  }

  /**
   * Extract address components from a Mapbox feature
   */
  private extractMapboxComponents(feature: any): any {
    const components: any &#x3D; {};

    if (!feature.context) {
      return components;
    }

    // Extract components from context
    feature.context.forEach((ctx: any) &#x3D;&gt; {
      const id &#x3D; ctx.id || &#x27;&#x27;;
      const text &#x3D; ctx.text || &#x27;&#x27;;

      if (id.startsWith(&#x27;country&#x27;)) {
        components.country &#x3D; text;
        // Extract country code from the ID (e.g., &quot;country.123&quot; -&gt; &quot;123&quot;)
        components.countryCode &#x3D; id.split(&#x27;.&#x27;)[1];
      } else if (id.startsWith(&#x27;region&#x27;)) {
        components.state &#x3D; text;
      } else if (id.startsWith(&#x27;postcode&#x27;)) {
        components.postalCode &#x3D; text;
      } else if (id.startsWith(&#x27;place&#x27;)) {
        components.city &#x3D; text;
      } else if (id.startsWith(&#x27;neighborhood&#x27;)) {
        components.neighborhood &#x3D; text;
      } else if (id.startsWith(&#x27;locality&#x27;)) {
        if (!components.neighborhood) {
          components.neighborhood &#x3D; text;
        }
      }
    });

    return components;
  }

  /**
   * Geocode an address using Google Maps
   */
  private googleGeocode(address: string): Observable&lt;EnhancedGeocodingResult | null&gt; {
    if (!GOOGLE_MAPS_API_KEY) {
      console.error(&#x27;Google Maps API key not provided&#x27;);
      return of(null);
    }

    const encodedAddress &#x3D; encodeURIComponent(address);
    const url &#x3D; &#x60;https://maps.googleapis.com/maps/api/geocode/json?address&#x3D;${encodedAddress}&amp;key&#x3D;${GOOGLE_MAPS_API_KEY}&#x60;;

    return this.http.get&lt;any&gt;(url).pipe(
      map(response &#x3D;&gt; {
        if (response.status !&#x3D;&#x3D; &#x27;OK&#x27; || !response.results || response.results.length &#x3D;&#x3D;&#x3D; 0) {
          return null;
        }

        const result &#x3D; response.results[0];
        const location &#x3D; result.geometry.location;
        const components &#x3D; this.extractGoogleComponents(result.address_components);

        return {
          id: result.place_id,
          name: result.formatted_address.split(&#x27;,&#x27;)[0] || &#x27;&#x27;,
          formattedAddress: result.formatted_address,
          latitude: location.lat,
          longitude: location.lng,
          country: components.country,
          countryCode: components.countryCode,
          city: components.city,
          state: components.state,
          postalCode: components.postalCode,
          neighborhood: components.neighborhood,
          provider: &#x27;google&#x27;,
          timestamp: Date.now(),
        };
      }),
      catchError(error &#x3D;&gt; {
        console.error(&#x27;Error geocoding with Google Maps:&#x27;, error);
        return of(null);
      })
    );
  }

  /**
   * Reverse geocode coordinates using Google Maps
   */
  private googleReverseGeocode(
    latitude: number,
    longitude: number
  ): Observable&lt;ReverseGeocodingResult | null&gt; {
    if (!GOOGLE_MAPS_API_KEY) {
      console.error(&#x27;Google Maps API key not provided&#x27;);
      return of(null);
    }

    const url &#x3D; &#x60;https://maps.googleapis.com/maps/api/geocode/json?latlng&#x3D;${latitude},${longitude}&amp;key&#x3D;${GOOGLE_MAPS_API_KEY}&#x60;;

    return this.http.get&lt;any&gt;(url).pipe(
      map(response &#x3D;&gt; {
        if (response.status !&#x3D;&#x3D; &#x27;OK&#x27; || !response.results || response.results.length &#x3D;&#x3D;&#x3D; 0) {
          return null;
        }

        const result &#x3D; response.results[0];
        const components &#x3D; this.extractGoogleComponents(result.address_components);

        return {
          formattedAddress: result.formatted_address,
          latitude,
          longitude,
          components,
          provider: &#x27;google&#x27;,
          timestamp: Date.now(),
        };
      }),
      catchError(error &#x3D;&gt; {
        console.error(&#x27;Error reverse geocoding with Google Maps:&#x27;, error);
        return of(null);
      })
    );
  }

  /**
   * Get nearby places using Google Maps
   */
  private googleNearbyPlaces(
    latitude: number,
    longitude: number,
    radius: number,
    type?: string
  ): Observable&lt;EnhancedGeocodingResult[]&gt; {
    if (!GOOGLE_MAPS_API_KEY) {
      console.error(&#x27;Google Maps API key not provided&#x27;);
      return of([]);
    }

    // Convert radius from km to meters for the API
    const radiusInMeters &#x3D; radius * 1000;

    let url &#x3D; &#x60;https://maps.googleapis.com/maps/api/place/nearbysearch/json?location&#x3D;${latitude},${longitude}&amp;radius&#x3D;${radiusInMeters}&amp;key&#x3D;${GOOGLE_MAPS_API_KEY}&#x60;;

    // Add type if provided
    if (type) {
      url +&#x3D; &#x60;&amp;type&#x3D;${type}&#x60;;
    }

    return this.http.get&lt;any&gt;(url).pipe(
      map(response &#x3D;&gt; {
        if (response.status !&#x3D;&#x3D; &#x27;OK&#x27; || !response.results) {
          return [];
        }

        return response.results.map((place: any) &#x3D;&gt; {
          const location &#x3D; place.geometry.location;

          return {
            id: place.place_id,
            name: place.name,
            formattedAddress: place.vicinity,
            latitude: location.lat,
            longitude: location.lng,
            provider: &#x27;google&#x27;,
            timestamp: Date.now(),
          };
        });
      }),
      catchError(error &#x3D;&gt; {
        console.error(&#x27;Error getting nearby places with Google Maps:&#x27;, error);
        return of([]);
      })
    );
  }

  /**
   * Extract address components from Google address_components
   */
  private extractGoogleComponents(addressComponents: any[]): any {
    const components: any &#x3D; {};

    if (!addressComponents || !Array.isArray(addressComponents)) {
      return components;
    }

    // Map of Google address component types to our component names
    const componentMap: { [key: string]: string } &#x3D; {
      country: &#x27;country&#x27;,
      administrative_area_level_1: &#x27;state&#x27;,
      locality: &#x27;city&#x27;,
      postal_code: &#x27;postalCode&#x27;,
      neighborhood: &#x27;neighborhood&#x27;,
      sublocality: &#x27;neighborhood&#x27;,
      route: &#x27;street&#x27;,
      street_number: &#x27;streetNumber&#x27;,
    };

    // Extract each component
    addressComponents.forEach(component &#x3D;&gt; {
      const types &#x3D; component.types || [];

      types.forEach(type &#x3D;&gt; {
        if (componentMap[type]) {
          components[componentMap[type]] &#x3D; component.long_name;

          // Special case for country code
          if (type &#x3D;&#x3D;&#x3D; &#x27;country&#x27;) {
            components.countryCode &#x3D; component.short_name;
          }
        }
      });
    });

    return components;
  }
}
</code></pre>
    </div>
</div>








                   </div><div class="search-results">
    <div class="has-results">
        <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
        <ul class="search-results-list"></ul>
    </div>
    <div class="no-results">
        <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
    </div>
</div>
</div>
               <!-- END CONTENT -->
           </div>
       </div>

          <label class="dark-mode-switch">
               <input type="checkbox">
               <span class="slider">
                    <svg class="slider-icon" viewBox="0 0 24 24" fill="none" height="20" stroke="#000" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" width="20" xmlns="http://www.w3.org/2000/svg">
                    <path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"></path>
                    </svg>
               </span>
          </label>

       <script>
            var COMPODOC_CURRENT_PAGE_DEPTH = 1;
            var COMPODOC_CURRENT_PAGE_CONTEXT = 'interface';
            var COMPODOC_CURRENT_PAGE_URL = 'CachedResult.html';
            var MAX_SEARCH_RESULTS = 15;
       </script>

       <script>
               $darkModeToggleSwitchers = document.querySelectorAll('.dark-mode-switch input');
               checkToggle(darkModeState);
               if ($darkModeToggleSwitchers.length > 0) {
                    for (var i = 0; i < $darkModeToggleSwitchers.length; i++) {
                         $darkModeToggleSwitchers[i].addEventListener('change', function (event) {
                              darkModeState = !darkModeState;
                              toggleDarkMode(darkModeState);
                         });
                    }
               }
          </script>

       <script src="../js/libs/custom-elements.min.js"></script>
       <script src="../js/libs/lit-html.js"></script>

       <script src="../js/menu-wc.js" defer></script>
       <script nomodule src="../js/menu-wc_es5.js" defer></script>

       <script src="../js/libs/bootstrap-native.js"></script>

       <script src="../js/libs/es6-shim.min.js"></script>
       <script src="../js/libs/EventDispatcher.js"></script>
       <script src="../js/libs/promise.min.js"></script>

       <script src="../js/compodoc.js"></script>

       <script src="../js/tabs.js"></script>
       <script src="../js/menu.js"></script>
       <script src="../js/libs/clipboard.min.js"></script>
       <script src="../js/libs/prism.js"></script>
       <script src="../js/sourceCode.js"></script>
          <script src="../js/search/search.js"></script>
          <script src="../js/search/lunr.min.js"></script>
          <script src="../js/search/search-lunr.js"></script>
          <script src="../js/search/search_index.js"></script>
       <script src="../js/lazy-load-graphs.js"></script>


    </body>
</html>
